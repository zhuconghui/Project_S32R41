IPA function summary for init_data_bss/0 inlinable
  global time:     963.462853
  self size:       34
  global size:     34
  min size:       0
  self stack:      0
  global stack:    0
    size:31.000000, time:961.462853
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:


Flattening functions:
Overall time estimate: 963.462853 weighted by profile: 0.000000

Deciding on inlining of small functions.  Starting with size 0.
Enqueueing calls in init_data_bss/0.

Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:

Deciding on functions to be inlined into all callers and removing useless speculations:
Overall time estimate: 963.462853 weighted by profile: 0.000000

Why inlining failed?
IPA function summary for init_data_bss/0 inlinable
  global time:     963.462853
  self size:       34
  global size:     34
  min size:       0
  self stack:      0
  global stack:    0
    size:31.000000, time:961.462853
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:

Symbol table:

__ZERO_TABLE/2 (__ZERO_TABLE) @05f66e58
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: init_data_bss/0 (read)init_data_bss/0 (addr)
  Availability: not_available
  Varpool flags:
__INIT_TABLE/1 (__INIT_TABLE) @05f66e10
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: init_data_bss/0 (read)init_data_bss/0 (addr)
  Availability: not_available
  Varpool flags:
init_data_bss/0 (init_data_bss) @05f63d20
  Type: function definition analyzed
  Visibility: externally_visible public
  References: __INIT_TABLE/1 (read)__INIT_TABLE/1 (addr)__ZERO_TABLE/2 (read)__ZERO_TABLE/2 (addr)
  Referring: 
  Availability: available
  Function flags: count:14598062 (estimated locally) body optimize_size
  Called by: 
  Calls: 

;; Function init_data_bss (init_data_bss, funcdef_no=0, decl_uid=5457, cgraph_uid=1, symbol_order=0)

init_data_bss ()
{
  uint32 j;
  uint32 i;
  uintptr size;
  uint32 len;
  uint8 * ram;
  const uint8 * rom;
  long unsigned int _1;
  const struct Sys_CopyLayoutType * _2;
  uint8 * _3;
  int _4;
  const uint8 * _5;
  uint8 * _6;
  unsigned char _7;
  long unsigned int _8;
  const struct Sys_ZeroLayoutType * _9;
  uint8 * _10;
  int _11;
  uint8 * _12;

  <bb 2> [local count: 14598062]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG len => 0
  # DEBUG BEGIN_STMT
  # DEBUG size => 0
  # DEBUG BEGIN_STMT
  # DEBUG i => 0
  # DEBUG BEGIN_STMT
  # DEBUG j => 0
  # DEBUG BEGIN_STMT
  # DEBUG initTable_Ptr => &__INIT_TABLE
  # DEBUG BEGIN_STMT
  # DEBUG zeroTable_Ptr => &__ZERO_TABLE
  # DEBUG BEGIN_STMT
  len_22 = MEM[(const uintptr *)&__INIT_TABLE];
  # DEBUG len => len_22
  # DEBUG BEGIN_STMT
  # DEBUG initTable_Ptr => &MEM[(void *)&__INIT_TABLE + 4B]
  # DEBUG BEGIN_STMT
  # DEBUG copy_layout => &MEM[(void *)&__INIT_TABLE + 4B]
  # DEBUG BEGIN_STMT
  # DEBUG i => 0
  goto <bb 7>; [100.00%]

  <bb 3> [local count: 118111595]:
  # DEBUG BEGIN_STMT
  _1 = i_13 * 12;
  _2 = &MEM[(void *)&__INIT_TABLE + 4B] + _1;
  rom_29 = _2->rom_start;
  # DEBUG rom => rom_29
  # DEBUG BEGIN_STMT
  ram_30 = _2->ram_start;
  # DEBUG ram => ram_30
  # DEBUG BEGIN_STMT
  _3 = _2->rom_end;
  _4 = _3 - rom_29;
  size_31 = (uintptr) _4;
  # DEBUG size => size_31
  # DEBUG BEGIN_STMT
  # DEBUG j => 0
  goto <bb 5>; [100.00%]

  <bb 4> [local count: 955630185]:
  # DEBUG BEGIN_STMT
  _5 = rom_29 + j_15;
  _6 = ram_30 + j_15;
  _7 = *_5;
  *_6 = _7;
  # DEBUG BEGIN_STMT
  j_34 = j_15 + 1;
  # DEBUG j => j_34

  <bb 5> [local count: 1073741782]:
  # j_15 = PHI <0(3), j_34(4)>
  # DEBUG j => j_15
  # DEBUG BEGIN_STMT
  if (j_15 < size_31)
    goto <bb 4>; [89.00%]
  else
    goto <bb 6>; [11.00%]

  <bb 6> [local count: 118111596]:
  # DEBUG BEGIN_STMT
  i_32 = i_13 + 1;
  # DEBUG i => i_32

  <bb 7> [local count: 132709658]:
  # i_13 = PHI <0(2), i_32(6)>
  # DEBUG i => i_13
  # DEBUG BEGIN_STMT
  if (i_13 < len_22)
    goto <bb 3>; [89.00%]
  else
    goto <bb 8>; [11.00%]

  <bb 8> [local count: 14598062]:
  # DEBUG BEGIN_STMT
  len_23 = MEM[(const uintptr *)&__ZERO_TABLE];
  # DEBUG len => len_23
  # DEBUG BEGIN_STMT
  # DEBUG zeroTable_Ptr => &MEM[(void *)&__ZERO_TABLE + 4B]
  # DEBUG BEGIN_STMT
  # DEBUG zero_layout => &MEM[(void *)&__ZERO_TABLE + 4B]
  # DEBUG BEGIN_STMT
  # DEBUG i => 0
  goto <bb 13>; [100.00%]

  <bb 9> [local count: 118111600]:
  # DEBUG BEGIN_STMT
  _8 = i_14 * 8;
  _9 = &MEM[(void *)&__ZERO_TABLE + 4B] + _8;
  ram_24 = _9->ram_start;
  # DEBUG ram => ram_24
  # DEBUG BEGIN_STMT
  _10 = _9->ram_end;
  _11 = _10 - ram_24;
  size_25 = (uintptr) _11;
  # DEBUG size => size_25
  # DEBUG BEGIN_STMT
  # DEBUG j => 0
  goto <bb 11>; [100.00%]

  <bb 10> [local count: 955630224]:
  # DEBUG BEGIN_STMT
  _12 = ram_24 + j_16;
  *_12 = 0;
  # DEBUG BEGIN_STMT
  j_28 = j_16 + 1;
  # DEBUG j => j_28

  <bb 11> [local count: 1073741824]:
  # j_16 = PHI <0(9), j_28(10)>
  # DEBUG j => j_16
  # DEBUG BEGIN_STMT
  if (j_16 < size_25)
    goto <bb 10>; [89.00%]
  else
    goto <bb 12>; [11.00%]

  <bb 12> [local count: 118111601]:
  # DEBUG BEGIN_STMT
  i_26 = i_14 + 1;
  # DEBUG i => i_26

  <bb 13> [local count: 132709663]:
  # i_14 = PHI <0(8), i_26(12)>
  # DEBUG i => i_14
  # DEBUG BEGIN_STMT
  if (i_14 < len_23)
    goto <bb 9>; [89.00%]
  else
    goto <bb 14>; [11.00%]

  <bb 14> [local count: 14598063]:
  return;

}



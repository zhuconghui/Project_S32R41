IPA function summary for netif_null_output_ip6.constprop/68 inlinable
  global time:     2.000000
  self size:       3
  global size:     3
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:

IPA function summary for netif_get_ip6_addr_match.part.0/67 inlinable
  global time:     30.872560
  self size:       25
  global size:     25
  min size:       0
  self stack:      0
  global stack:    0
    size:15.500000, time:24.024745
    size:5.500000, time:4.612706,  executed if:(not inlined)
    size:0.500000, time:0.747576,  executed if:(not inlined),  nonconst if:(op1[ref offset: 0] changed) && (not inlined)
    size:0.500000, time:0.747576,  nonconst if:(op1[ref offset: 0] changed)
    size:0.500000, time:0.254176,  executed if:(not inlined),  nonconst if:(op1[ref offset: 32] changed) && (not inlined)
    size:0.500000, time:0.254176,  nonconst if:(op1[ref offset: 32] changed)
    size:0.500000, time:0.086420,  executed if:(not inlined),  nonconst if:(op1[ref offset: 64] changed) && (not inlined)
    size:0.500000, time:0.086420,  nonconst if:(op1[ref offset: 64] changed)
    size:0.500000, time:0.029383,  executed if:(not inlined),  nonconst if:(op1[ref offset: 96] changed) && (not inlined)
    size:0.500000, time:0.029383,  nonconst if:(op1[ref offset: 96] changed)
  calls:

IPA function summary for netif_ip6_addr_set_state.part.0/66 inlinable
  global time:     19.025000
  self size:       31
  global size:     31
  min size:       20
  self stack:      0
  global stack:    0
    size:8.000000, time:6.130000
    size:4.000000, time:2.830000,  executed if:(not inlined)
    size:5.000000, time:1.980000,  nonconst if:(op2 changed)
    size:0.500000, time:0.330000,  executed if:(not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (not inlined)
    size:3.500000, time:2.310000,  nonconst if:(op0[ref offset: 1784] changed)
  array index:(op1 changed)
  calls:
    nd6_adjust_mld_membership/54 function body not available
      loop depth: 0 freq:0.22 size: 4 time: 13
    netif_do_ip_addr_changed/9 function not considered for inlining
      loop depth: 0 freq:0.11 size: 3 time: 12callee size: 6 stack: 0
       op1 is compile time invariant
    netif_issue_reports/20 function not considered for inlining
      loop depth: 0 freq:0.11 size: 3 time: 12callee size:16 stack: 0
       op1 is compile time invariant

IPA function summary for netif_ip6_addr_set_parts.part.0/65 inlinable
  global time:     45.455898
  self size:       60
  global size:     60
  min size:       12
  self stack:      48
  global stack:    48
    size:37.500000, time:26.064367
    size:11.500000, time:7.946547,  executed if:(not inlined)
    size:3.000000, time:2.959910,  nonconst if:(op2 changed)
    size:0.500000, time:0.167728,  executed if:(not inlined),  nonconst if:(op0[ref offset: 1808] changed) && (not inlined)
    size:1.500000, time:0.503185,  nonconst if:(op0[ref offset: 1808] changed)
  array index:(op1 changed)
  calls:
    netif_do_ip_addr_changed/9 function not considered for inlining
      loop depth: 0 freq:0.33 size: 3 time: 12callee size: 6 stack: 0
       op1 is compile time invariant
    netif_issue_reports/20 function not considered for inlining
      loop depth: 0 freq:0.33 size: 3 time: 12callee size:16 stack: 0
       op1 is compile time invariant

IPA function summary for netif_do_set_ipaddr.part.0/61 inlinable
  global time:     26.680000
  self size:       38
  global size:     38
  min size:       12
  self stack:      24
  global stack:    24
    size:17.500000, time:8.090000
    size:13.500000, time:5.590000,  executed if:(not inlined)
    size:0.500000, time:0.500000,  executed if:(not inlined),  nonconst if:(op1[ref offset: 0] changed) && (not inlined)
    size:0.500000, time:0.500000,  nonconst if:(op1[ref offset: 0] changed)
  calls:
    netif_do_ip_addr_changed/9 function not considered for inlining
      loop depth: 0 freq:0.50 size: 3 time: 12callee size: 6 stack: 0
       op1 is compile time invariant
    netif_issue_reports/20 function not considered for inlining
      loop depth: 0 freq:0.50 size: 3 time: 12callee size:16 stack: 0
       op1 is compile time invariant

IPA function summary for netif_issue_reports.part.0/60 inlinable
  global time:     8.630000
  self size:       8
  global size:     8
  min size:       4
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:3.000000, time:3.000000,  nonconst if:(op1 changed)
  calls:
    mld6_report_groups/48 function body not available
      loop depth: 0 freq:0.33 size: 2 time: 11

IPA function summary for netif_find/36 inlinable
  global time:     107.473014
  self size:       29
  global size:     29
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:1.000000, time:0.845300,  executed if:(op0 != 0B),  nonconst if:(op0 changed) && (op0 != 0B)
    size:18.500000, time:89.722593,  executed if:(op0 != 0B)
    size:1.500000, time:2.761521,  executed if:(op0 != 0B) && (not inlined)
  calls:
    atoi/57 function body not available
      loop depth: 0 freq:0.85 size: 3 time: 12 predicate: (op0 != 0B)

IPA function summary for netif_get_by_index/35 inlinable
  global time:     48.999299
  self size:       13
  global size:     13
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:8.000000, time:44.999299,  executed if:(op0 != 0)
  calls:

IPA function summary for netif_index_to_name/34 inlinable
  global time:     27.244200
  self size:       18
  global size:     18
  min size:       14
  self stack:      0
  global stack:    0
    size:5.000000, time:3.775400
    size:4.000000, time:2.591800,  executed if:(not inlined)
    size:1.000000, time:0.591800,  nonconst if:(op1 changed)
    size:1.000000, time:0.591800,  nonconst if:(op0 changed)
  calls:
    lwip_itoa/56 function body not available
      loop depth: 0 freq:0.59 size: 4 time: 13
       op1 is compile time invariant
    netif_get_by_index/35 function not considered for inlining
      loop depth: 0 freq:1.00 size: 3 time: 12callee size: 6 stack: 0

IPA function summary for netif_name_to_index/33 inlinable
  global time:     17.091800
  self size:       10
  global size:     10
  min size:       6
  self stack:      0
  global stack:    0
    size:4.000000, time:3.091800
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:
    netif_find/36 function not considered for inlining
      loop depth: 0 freq:1.00 size: 3 time: 12callee size:14 stack: 0

IPA function summary for netif_null_output_ip4/32 inlinable
  global time:     16.000000
  self size:       8
  global size:     8
  min size:       10
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:
    netif_null_output_ip6.constprop/68 function not considered for inlining
      loop depth: 0 freq:1.00 size: 5 time: 14callee size: 1 stack: 0

IPA function summary for netif_null_output_ip6/31 inlinable
  global time:     2.000000
  self size:       3
  global size:     3
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:

IPA function summary for netif_add_ip6_address/30 inlinable
  global time:     12540.158279
  self size:       56
  global size:     56
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.400002,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:20.500000, time:12.839593,  executed if:(op1 != 0B) && (op0 != 0B)
    size:8.500000, time:2.449877,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined)
    size:6.000000, time:0.748581,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op2 changed) && (op1 != 0B) && (op0 != 0B)
    size:1.500000, time:0.131001,  executed if:(op2 != 0B) && (op1 != 0B) && (op0 != 0B) && (not inlined)
    size:1.500000, time:0.131001,  executed if:(op2 != 0B) && (op1 != 0B) && (op0 != 0B)
    size:2.000000, time:6514.218086,  executed if:(op1 == 0B) && (op0 != 0B)
    size:2.000000, time:6000.016663,  executed if:(op0 == 0B)
  calls:
    netif_ip6_addr_set_state/27 function not considered for inlining
      loop depth: 0 freq:0.10 size: 4 time: 13callee size: 7 stack: 0 predicate: (op1 != 0B) && (op0 != 0B)
       op2 is compile time invariant
    netif_get_ip6_addr_match/28 function not considered for inlining
      loop depth: 0 freq:0.37 size: 4 time: 13callee size:11 stack: 0 predicate: (op1 != 0B) && (op0 != 0B)

IPA function summary for netif_create_ip6_linklocal_address/29 inlinable
  global time:     6103.725945
  self size:       71
  global size:     71
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:3.500000, time:2.918998,  executed if:(op0 != 0B) && (not inlined)
    size:6.500000, time:3.856997,  executed if:(op0 != 0B)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:3.000000, time:5.465547,  executed if:(op1 == 0) && (op0 != 0B) && (not inlined)
    size:17.000000, time:39.255273,  executed if:(op1 == 0) && (op0 != 0B)
    size:0.500000, time:0.115500,  executed if:(op1 != 0) && (op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1728] changed) && (op1 != 0) && (op0 != 0B) && (not inlined)
    size:2.500000, time:0.577501,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1728] changed) && (op1 != 0) && (op0 != 0B)
    size:0.500000, time:0.115500,  executed if:(op1 != 0) && (op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1736] changed) && (op1 != 0) && (op0 != 0B) && (not inlined)
    size:1.500000, time:0.346500,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1736] changed) && (op1 != 0) && (op0 != 0B)
    size:1.000000, time:0.231000,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1728] changed || op0[ref offset: 1736] changed) && (op1 != 0) && (op0 != 0B)
    size:0.500000, time:0.115500,  executed if:(op1 != 0) && (op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1744] changed) && (op1 != 0) && (op0 != 0B) && (not inlined)
    size:1.500000, time:0.346500,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1744] changed) && (op1 != 0) && (op0 != 0B)
    size:2.000000, time:0.462001,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1728] changed || op0[ref offset: 1736] changed || op0[ref offset: 1744] changed) && (op1 != 0) && (op0 != 0B)
    size:2.500000, time:0.577501,  executed if:(op1 != 0) && (op0 != 0B) && (not inlined)
    size:7.500000, time:1.732502,  executed if:(op1 != 0) && (op0 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op0 == 0B)
  calls:
    netif_ip6_addr_set_state/27 function not considered for inlining
      loop depth: 0 freq:0.70 size: 4 time: 13callee size: 7 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant
       op2 is compile time invariant
    lwip_htonl/55 function body not available
      loop depth: 1 freq:2.46 size: 3 time: 12 predicate: (op1 == 0) && (op0 != 0B)
    lwip_htonl/55 function body not available
      loop depth: 0 freq:0.23 size: 3 time: 12 predicate: (op1 != 0) && (op0 != 0B)
    lwip_htonl/55 function body not available
      loop depth: 0 freq:0.23 size: 3 time: 12 predicate: (op1 != 0) && (op0 != 0B)

IPA function summary for netif_get_ip6_addr_match/28 inlinable
  global time:     10213.163162
  self size:       22
  global size:     22
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:0.500000, time:0.245001,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op1[ref offset: 128] changed) && (op1 != 0B) && (op0 != 0B) && (not inlined)
    size:2.500000, time:1.225004,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 128] changed) && (op1 != 0B) && (op0 != 0B)
    size:0.500000, time:0.122500,  executed if:(op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1808] changed) && (op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B) && (not inlined)
    size:1.500000, time:0.367501,  executed if:(op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B),  nonconst if:(op0[ref offset: 1808] changed) && (op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B)
    size:2.000000, time:0.490002,  executed if:(op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 128] changed || op0[ref offset: 1808] changed) && (op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B)
    size:1.000000, time:0.980004,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined)
    size:2.000000, time:4200.011055,  executed if:(op1 == 0B) && (op0 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op0 == 0B)
  calls:
    netif_get_ip6_addr_match.part.0/67 function not considered for inlining
      loop depth: 0 freq:0.49 size: 4 time: 13callee size:12 stack: 0 predicate: (op1 != 0B) && (op0 != 0B)

IPA function summary for netif_ip6_addr_set_state/27 inlinable
  global time:     13008.666016
  self size:       15
  global size:     15
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:1.000000, time:0.700000,  executed if:(op1 <= 2) && (op0 != 0B) && (not inlined)
    size:2.000000, time:7000.008629,  executed if:(op1 > 2) && (op0 != 0B)
    size:2.000000, time:6000.007385,  executed if:(op0 == 0B)
  calls:
    netif_ip6_addr_set_state.part.0/66 function not considered for inlining
      loop depth: 0 freq:0.35 size: 4 time: 13callee size:15 stack: 0 predicate: (op1 <= 2) && (op0 != 0B)

IPA function summary for netif_ip6_addr_set_parts/26 inlinable
  global time:     13009.716003
  self size:       18
  global size:     18
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:1.000000, time:0.700000,  executed if:(op1 <= 2) && (op0 != 0B) && (not inlined)
    size:2.000000, time:7000.008629,  executed if:(op1 > 2) && (op0 != 0B)
    size:2.000000, time:6000.007385,  executed if:(op0 == 0B)
  calls:
    netif_ip6_addr_set_parts.part.0/65 function not considered for inlining
      loop depth: 0 freq:0.35 size: 7 time: 16callee size:30 stack:48 predicate: (op1 <= 2) && (op0 != 0B)

IPA function summary for netif_ip6_addr_set/25 inlinable
  global time:     12525.869141
  self size:       22
  global size:     22
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.400002,  executed if:(op0 != 0B),  nonconst if:(op2 changed) && (op0 != 0B)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op2[ref offset: 0] changed) && (op2 != 0B) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B),  nonconst if:(op2[ref offset: 0] changed) && (op2 != 0B) && (op0 != 0B)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op2[ref offset: 32] changed) && (op2 != 0B) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B),  nonconst if:(op2[ref offset: 32] changed) && (op2 != 0B) && (op0 != 0B)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op2[ref offset: 64] changed) && (op2 != 0B) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B),  nonconst if:(op2[ref offset: 64] changed) && (op2 != 0B) && (op0 != 0B)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op2[ref offset: 96] changed) && (op2 != 0B) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B),  nonconst if:(op2[ref offset: 96] changed) && (op2 != 0B) && (op0 != 0B)
    size:1.000000, time:0.748581,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined)
    size:2.000000, time:6514.218086,  executed if:(op2 == 0B) && (op0 != 0B)
    size:2.000000, time:6000.016663,  executed if:(op0 == 0B)
  calls:
    netif_ip6_addr_set_parts/26 function not considered for inlining
      loop depth: 0 freq:0.37 size: 7 time: 16callee size: 9 stack: 0 predicate: (op2 != 0B) && (op0 != 0B)

IPA function summary for netif_alloc_client_data_id/24 inlinable
  global time:     10006.016983
  self size:       10
  global size:     10
  min size:       0
  self stack:      0
  global stack:    0
    size:7.000000, time:10005.016983
    size:3.000000, time:1.000000,  executed if:(not inlined)
  calls:

IPA function summary for netif_set_link_down/23 inlinable
  global time:     8.914600
  self size:       13
  global size:     13
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.409550,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:4.500000, time:3.276400,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:1.000000, time:0.409550,  executed if:(op0 != 0B) && (not inlined)
    size:1.000000, time:0.409550,  executed if:(op0 != 0B)
    size:0.500000, time:0.204775,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1696] changed) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.204775,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1696] changed) && (op0 != 0B)
  calls:

IPA function summary for netif_set_link_up/22 inlinable
  global time:     14.033975
  self size:       16
  global size:     16
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.409550,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:4.500000, time:3.137153,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:0.500000, time:0.135151,  executed if:(op0 != 0B) && (not inlined)
    size:0.500000, time:0.135151,  executed if:(op0 != 0B)
  calls:
    nd6_restart_netif/41 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)
    netif_issue_reports/20 function not considered for inlining
      loop depth: 0 freq:0.27 size: 3 time: 12callee size:16 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant

IPA function summary for netif_set_down/21 inlinable
  global time:     16.366690
  self size:       23
  global size:     23
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.409550,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:4.500000, time:3.137153,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:1.500000, time:0.405454,  executed if:(op0 != 0B) && (not inlined)
    size:5.500000, time:1.486666,  executed if:(op0 != 0B)
  calls:
    nd6_cleanup_netif/53 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)
    etharp_cleanup_netif/52 function body not available
      loop depth: 0 freq:0.09 size: 2 time: 11 predicate: (op0 != 0B)
    sys_now/51 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)

IPA function summary for netif_issue_reports/20 inlinable
  global time:     6013.267433
  self size:       32
  global size:     32
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.350000,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:6.500000, time:2.712496,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:3.000000, time:1.050004,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:2.000000, time:1.531249,  executed if:(op0 != 0B) && (not inlined)
    size:6.000000, time:0.743748,  executed if:(op0 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op0 == 0B)
  calls:
    netif_issue_reports.part.0/60 function not considered for inlining
      loop depth: 0 freq:0.35 size: 3 time: 12callee size: 4 stack: 0 predicate: (op0 != 0B)
    igmp_report_groups/47 function body not available
      loop depth: 0 freq:0.03 size: 2 time: 11 predicate: (op0 != 0B)
    etharp_request/46 function body not available
      loop depth: 0 freq:0.03 size: 3 time: 12 predicate: (op0 != 0B)

IPA function summary for netif_set_up/19 inlinable
  global time:     17.547914
  self size:       20
  global size:     20
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.409550,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:4.500000, time:3.137153,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:1.000000, time:0.270303,  executed if:(op0 != 0B) && (not inlined)
    size:2.000000, time:0.540606,  executed if:(op0 != 0B)
  calls:
    nd6_restart_netif/41 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)
    netif_issue_reports/20 function not considered for inlining
      loop depth: 0 freq:0.27 size: 3 time: 12callee size:16 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant
    sys_now/51 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)

IPA function summary for netif_set_default/18 inlinable
  global time:     3.000000
  self size:       4
  global size:     4
  min size:       0
  self stack:      0
  global stack:    0
    size:1.000000, time:1.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:

IPA function summary for netif_remove/17 inlinable
  global time:     91.085433
  self size:       50
  global size:     50
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:3.000000, time:2.719454,  executed if:(op0 != 0B) && (not inlined)
    size:30.000000, time:56.434669,  executed if:(op0 != 0B)
  calls:
    netif_set_down/21 function not considered for inlining
      loop depth: 0 freq:0.27 size: 2 time: 11callee size:11 stack: 0 predicate: (op0 != 0B)
    mld6_stop/50 function body not available
      loop depth: 0 freq:0.82 size: 2 time: 11 predicate: (op0 != 0B)
    netif_do_ip_addr_changed/9 function not considered for inlining
      loop depth: 1 freq:0.81 size: 3 time: 12callee size: 6 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant
    igmp_stop/49 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)
    netif_do_ip_addr_changed/9 function not considered for inlining
      loop depth: 0 freq:0.27 size: 3 time: 12callee size: 6 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant

IPA function summary for netif_set_addr/16 inlinable
  global time:     36.400050
  self size:       36
  global size:     36
  min size:       16
  self stack:      24
  global stack:    24
    size:16.000000, time:14.477100
    size:6.000000, time:4.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op1 changed)
    size:2.000000, time:2.000000,  nonconst if:(op2 changed)
    size:2.000000, time:2.000000,  nonconst if:(op3 changed)
  calls:
    netif_do_set_ipaddr/10 function not considered for inlining
      loop depth: 0 freq:0.33 size: 4 time: 13callee size: 8 stack: 0
       op2 is compile time invariant
    netif_do_set_ipaddr/10 function not considered for inlining
      loop depth: 0 freq:0.59 size: 4 time: 13callee size: 8 stack: 0
       op2 is compile time invariant

IPA function summary for netif_set_gw/15 inlinable
  global time:     9.733700
  self size:       13
  global size:     13
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.638200,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:4.500000, time:3.276400,  executed if:(op0 != 0B)
    size:1.500000, time:0.819100,  executed if:(op0 != 0B) && (not inlined)
  calls:

IPA function summary for netif_set_netmask/13 inlinable
  global time:     9.733700
  self size:       13
  global size:     13
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.638200,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:4.500000, time:3.276400,  executed if:(op0 != 0B)
    size:1.500000, time:0.819100,  executed if:(op0 != 0B) && (not inlined)
  calls:

IPA function summary for netif_set_ipaddr/11 inlinable
  global time:     16.286500
  self size:       11
  global size:     11
  min size:       0
  self stack:      24
  global stack:    24
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.638200,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
  calls:
    netif_do_set_ipaddr/10 function not considered for inlining
      loop depth: 0 freq:0.82 size: 4 time: 13callee size: 8 stack: 0 predicate: (op0 != 0B)
       op2 is compile time invariant

IPA function summary for netif_do_set_ipaddr/10 inlinable
  global time:     10211.266876
  self size:       16
  global size:     16
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op1 changed)
    size:2.000000, time:1.399999,  executed if:(op1 != 0B),  nonconst if:(op2 changed) && (op1 != 0B)
    size:1.000000, time:0.980004,  executed if:(op2 != 0B) && (op1 != 0B) && (not inlined)
    size:2.000000, time:4200.011055,  executed if:(op2 == 0B) && (op1 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op1 == 0B)
  calls:
    netif_do_set_ipaddr.part.0/61 function not considered for inlining
      loop depth: 0 freq:0.49 size: 5 time: 14callee size:19 stack:24 predicate: (op2 != 0B) && (op1 != 0B)

IPA function summary for netif_do_ip_addr_changed/9 inlinable
  global time:     38.000000
  self size:       12
  global size:     12
  min size:       18
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:
    raw_netif_ip_addr_changed/45 function body not available
      loop depth: 0 freq:1.00 size: 3 time: 12
    udp_netif_ip_addr_changed/44 function body not available
      loop depth: 0 freq:1.00 size: 3 time: 12
    tcp_netif_ip_addr_changed/43 function body not available
      loop depth: 0 freq:1.00 size: 3 time: 12

IPA function summary for netif_add/8 inlinable
  global time:     13527.869797
  self size:       113
  global size:     113
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:0.680637,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.834600,  executed if:(op0 != 0B),  nonconst if:(op5 changed) && (op0 != 0B)
    size:2.000000, time:1.682879,  executed if:(op5 != 0B) && (op0 != 0B),  nonconst if:(op1 changed) && (op5 != 0B) && (op0 != 0B)
    size:2.000000, time:1.682879,  executed if:(op5 != 0B) && (op0 != 0B),  nonconst if:(op2 changed) && (op5 != 0B) && (op0 != 0B)
    size:2.000000, time:1.682879,  executed if:(op5 != 0B) && (op0 != 0B),  nonconst if:(op3 changed) && (op5 != 0B) && (op0 != 0B)
    size:23.000000, time:33.745675,  executed if:(op5 != 0B) && (op0 != 0B) && (not inlined)
    size:59.000000, time:13438.152161,  executed if:(op5 != 0B) && (op0 != 0B)
  calls:
    igmp_start/42 function body not available
      loop depth: 0 freq:0.01 size: 2 time: 11 predicate: (op5 != 0B) && (op0 != 0B)
    netif_set_addr/16 function not considered for inlining
      loop depth: 0 freq:0.84 size: 5 time: 14callee size:18 stack:24 predicate: (op5 != 0B) && (op0 != 0B)
    nd6_restart_netif/41 function body not available
      loop depth: 0 freq:0.84 size: 2 time: 11 predicate: (op5 != 0B) && (op0 != 0B)
    memset/40 function body not available
      loop depth: 0 freq:0.84 size: 4 time: 13 predicate: (op5 != 0B) && (op0 != 0B)
       op1 is compile time invariant
       op2 is compile time invariant
    indirect call loop depth: 0 freq:0.84 size: 5 time: 17predicate: (op5 != 0B) && (op0 != 0B)

IPA function summary for netif_add_noaddr/7 inlinable
  global time:     20.000000
  self size:       12
  global size:     12
  min size:       18
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:
    netif_add/8 function not considered for inlining
      loop depth: 0 freq:1.00 size: 9 time: 18callee size:56 stack: 0
       op1 is compile time invariant
       op2 is compile time invariant
       op3 is compile time invariant

IPA function summary for netif_input/6 inlinable
  global time:     10212.736877
  self size:       23
  global size:     23
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:0.500000, time:0.245001,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op1[ref offset: 1784] changed) && (op1 != 0B) && (op0 != 0B) && (not inlined)
    size:3.500000, time:1.715006,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 1784] changed) && (op1 != 0B) && (op0 != 0B)
    size:1.000000, time:0.980004,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined)
    size:2.000000, time:4200.011055,  executed if:(op1 == 0B) && (op0 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op0 == 0B)
  calls:
    ip_input/38 function body not available
      loop depth: 0 freq:0.25 size: 4 time: 13 predicate: (op1 != 0B) && (op0 != 0B)
    ethernet_input/37 function body not available
      loop depth: 0 freq:0.25 size: 4 time: 13 predicate: (op1 != 0B) && (op0 != 0B)

IPA function summary for netif_init/5 inlinable
  global time:     2.000000
  self size:       3
  global size:     3
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:


Flattening functions:
Overall time estimate: 118007.030762 weighted by profile: 0.000000

Deciding on inlining of small functions.  Starting with size 0.
Enqueueing calls in netif_null_output_ip6.constprop/68.
Enqueueing calls in netif_get_ip6_addr_match.part.0/67.
Enqueueing calls in netif_ip6_addr_set_state.part.0/66.
Enqueueing calls in netif_ip6_addr_set_parts.part.0/65.
Enqueueing calls in netif_do_set_ipaddr.part.0/61.
Enqueueing calls in netif_issue_reports.part.0/60.
Enqueueing calls in netif_find/36.
Enqueueing calls in netif_get_by_index/35.
Enqueueing calls in netif_index_to_name/34.
Enqueueing calls in netif_name_to_index/33.
Enqueueing calls in netif_null_output_ip4/32.
Enqueueing calls in netif_null_output_ip6/31.
Enqueueing calls in netif_add_ip6_address/30.
Enqueueing calls in netif_create_ip6_linklocal_address/29.
Enqueueing calls in netif_get_ip6_addr_match/28.
Enqueueing calls in netif_ip6_addr_set_state/27.
Enqueueing calls in netif_ip6_addr_set_parts/26.
Enqueueing calls in netif_ip6_addr_set/25.
Enqueueing calls in netif_alloc_client_data_id/24.
Enqueueing calls in netif_set_link_down/23.
Enqueueing calls in netif_set_link_up/22.
Enqueueing calls in netif_set_down/21.
Enqueueing calls in netif_issue_reports/20.
Enqueueing calls in netif_set_up/19.
Enqueueing calls in netif_set_default/18.
Enqueueing calls in netif_remove/17.
Enqueueing calls in netif_set_addr/16.
Enqueueing calls in netif_set_gw/15.
Enqueueing calls in netif_set_netmask/13.
Enqueueing calls in netif_set_ipaddr/11.
Enqueueing calls in netif_do_set_ipaddr/10.
Enqueueing calls in netif_do_ip_addr_changed/9.
Enqueueing calls in netif_add/8.
Enqueueing calls in netif_add_noaddr/7.
Enqueueing calls in netif_input/6.
Enqueueing calls in netif_init/5.

Considering netif_null_output_ip6.constprop/68 with 3 size
 to be inlined into netif_null_output_ip4/32 in unknown:0
 Estimated badness is -inf, frequency 1.00.

Considering netif_issue_reports.part.0/60 with 8 size
 to be inlined into netif_issue_reports/20 in unknown:0
 Estimated badness is -0.288236, frequency 0.35.

Considering netif_get_ip6_addr_match.part.0/67 with 25 size
 to be inlined into netif_get_ip6_addr_match/28 in unknown:0
 Estimated badness is -0.072112, frequency 0.49.

Considering netif_ip6_addr_set_parts.part.0/65 with 60 size
 to be inlined into netif_ip6_addr_set_parts/26 in unknown:0
 Estimated badness is -0.013956, frequency 0.35.

Considering netif_do_set_ipaddr.part.0/61 with 38 size
 to be inlined into netif_do_set_ipaddr/10 in unknown:0
 Estimated badness is -0.002369, frequency 0.49.

Considering netif_ip6_addr_set_state.part.0/66 with 31 size
 to be inlined into netif_ip6_addr_set_state/27 in unknown:0
 Estimated badness is -0.000180, frequency 0.35.

Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:

Deciding on functions to be inlined into all callers and removing useless speculations:
Overall time estimate: 117876.079468 weighted by profile: 0.000000

Why inlining failed?
function body not available                       :       25 calls, 12.325744 freq, 0 count
--param max-inline-insns-auto limit reached       :        2 calls, 1.374291 freq, 0 count
call is unlikely and code size would grow         :       20 calls, 8.442683 freq, 0 count
IPA function summary for netif_find/36 inlinable
  global time:     107.473014
  self size:       29
  global size:     29
  min size:       0
  self stack:      0
  global stack:    0
  estimated growth:22
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:1.000000, time:0.845300,  executed if:(op0 != 0B),  nonconst if:(op0 changed) && (op0 != 0B)
    size:18.500000, time:89.722593,  executed if:(op0 != 0B)
    size:1.500000, time:2.761521,  executed if:(op0 != 0B) && (not inlined)
  calls:
    atoi/57 function body not available
      loop depth: 0 freq:0.85 size: 3 time: 12 predicate: (op0 != 0B)

IPA function summary for netif_get_by_index/35 inlinable
  global time:     48.999299
  self size:       13
  global size:     13
  min size:       0
  self stack:      0
  global stack:    0
  estimated growth:7
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:8.000000, time:44.999299,  executed if:(op0 != 0)
  calls:

IPA function summary for netif_index_to_name/34 inlinable
  global time:     27.244200
  self size:       18
  global size:     18
  min size:       14
  self stack:      0
  global stack:    0
    size:5.000000, time:3.775400
    size:4.000000, time:2.591800,  executed if:(not inlined)
    size:1.000000, time:0.591800,  nonconst if:(op1 changed)
    size:1.000000, time:0.591800,  nonconst if:(op0 changed)
  calls:
    lwip_itoa/56 function body not available
      loop depth: 0 freq:0.59 size: 4 time: 13
       op1 is compile time invariant
    netif_get_by_index/35 call is unlikely and code size would grow
      loop depth: 0 freq:1.00 size: 3 time: 12callee size: 6 stack: 0

IPA function summary for netif_name_to_index/33 inlinable
  global time:     17.091800
  self size:       10
  global size:     10
  min size:       6
  self stack:      0
  global stack:    0
    size:4.000000, time:3.091800
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:
    netif_find/36 call is unlikely and code size would grow
      loop depth: 0 freq:1.00 size: 3 time: 12callee size:14 stack: 0

IPA function summary for netif_null_output_ip4/32 inlinable
  global time:     2.000000
  self size:       8
  global size:     3
  min size:       10
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:
    netif_null_output_ip6.constprop/68 inlined
      loop depth: 0 freq:1.00 size: 5 time: 14callee size: 1 stack: 0
      Stack frame offset 0, callee self size 0, callee size 0

IPA function summary for netif_null_output_ip6/31 inlinable
  global time:     2.000000
  self size:       3
  global size:     3
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:

IPA function summary for netif_add_ip6_address/30 inlinable
  global time:     12540.158279
  self size:       56
  global size:     56
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.400002,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:20.500000, time:12.839593,  executed if:(op1 != 0B) && (op0 != 0B)
    size:8.500000, time:2.449877,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined)
    size:6.000000, time:0.748581,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op2 changed) && (op1 != 0B) && (op0 != 0B)
    size:1.500000, time:0.131001,  executed if:(op2 != 0B) && (op1 != 0B) && (op0 != 0B) && (not inlined)
    size:1.500000, time:0.131001,  executed if:(op2 != 0B) && (op1 != 0B) && (op0 != 0B)
    size:2.000000, time:6514.218086,  executed if:(op1 == 0B) && (op0 != 0B)
    size:2.000000, time:6000.016663,  executed if:(op0 == 0B)
  calls:
    netif_ip6_addr_set_state/27 call is unlikely and code size would grow
      loop depth: 0 freq:0.10 size: 4 time: 13callee size:19 stack: 0 predicate: (op1 != 0B) && (op0 != 0B)
       op2 is compile time invariant
    netif_get_ip6_addr_match/28 call is unlikely and code size would grow
      loop depth: 0 freq:0.37 size: 4 time: 13callee size:18 stack: 0 predicate: (op1 != 0B) && (op0 != 0B)

IPA function summary for netif_create_ip6_linklocal_address/29 inlinable
  global time:     6103.725945
  self size:       71
  global size:     71
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:3.500000, time:2.918998,  executed if:(op0 != 0B) && (not inlined)
    size:6.500000, time:3.856997,  executed if:(op0 != 0B)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:3.000000, time:5.465547,  executed if:(op1 == 0) && (op0 != 0B) && (not inlined)
    size:17.000000, time:39.255273,  executed if:(op1 == 0) && (op0 != 0B)
    size:0.500000, time:0.115500,  executed if:(op1 != 0) && (op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1728] changed) && (op1 != 0) && (op0 != 0B) && (not inlined)
    size:2.500000, time:0.577501,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1728] changed) && (op1 != 0) && (op0 != 0B)
    size:0.500000, time:0.115500,  executed if:(op1 != 0) && (op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1736] changed) && (op1 != 0) && (op0 != 0B) && (not inlined)
    size:1.500000, time:0.346500,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1736] changed) && (op1 != 0) && (op0 != 0B)
    size:1.000000, time:0.231000,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1728] changed || op0[ref offset: 1736] changed) && (op1 != 0) && (op0 != 0B)
    size:0.500000, time:0.115500,  executed if:(op1 != 0) && (op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1744] changed) && (op1 != 0) && (op0 != 0B) && (not inlined)
    size:1.500000, time:0.346500,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1744] changed) && (op1 != 0) && (op0 != 0B)
    size:2.000000, time:0.462001,  executed if:(op1 != 0) && (op0 != 0B),  nonconst if:(op0[ref offset: 1728] changed || op0[ref offset: 1736] changed || op0[ref offset: 1744] changed) && (op1 != 0) && (op0 != 0B)
    size:2.500000, time:0.577501,  executed if:(op1 != 0) && (op0 != 0B) && (not inlined)
    size:7.500000, time:1.732502,  executed if:(op1 != 0) && (op0 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op0 == 0B)
  calls:
    netif_ip6_addr_set_state/27 call is unlikely and code size would grow
      loop depth: 0 freq:0.70 size: 4 time: 13callee size:19 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant
       op2 is compile time invariant
    lwip_htonl/55 function body not available
      loop depth: 1 freq:2.46 size: 3 time: 12 predicate: (op1 == 0) && (op0 != 0B)
    lwip_htonl/55 function body not available
      loop depth: 0 freq:0.23 size: 3 time: 12 predicate: (op1 != 0) && (op0 != 0B)
    lwip_htonl/55 function body not available
      loop depth: 0 freq:0.23 size: 3 time: 12 predicate: (op1 != 0) && (op0 != 0B)

IPA function summary for netif_get_ip6_addr_match/28 inlinable
  global time:     10219.053406
  self size:       22
  global size:     36
  min size:       0
  self stack:      0
  global stack:    0
  estimated growth:14
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:0.500000, time:0.245001,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op1[ref offset: 128] changed) && (op1 != 0B) && (op0 != 0B) && (not inlined)
    size:2.500000, time:1.225004,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 128] changed) && (op1 != 0B) && (op0 != 0B)
    size:0.500000, time:0.122500,  executed if:(op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1808] changed) && (op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B) && (not inlined)
    size:1.500000, time:0.367501,  executed if:(op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B),  nonconst if:(op0[ref offset: 1808] changed) && (op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B)
    size:2.000000, time:0.490002,  executed if:(op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 128] changed || op0[ref offset: 1808] changed) && (op1[ref offset: 128] != 0) && (op1 != 0B) && (op0 != 0B)
    size:1.000000, time:0.980004,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined)
    size:2.000000, time:4200.011055,  executed if:(op1 == 0B) && (op0 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op0 == 0B)
    size:15.500000, time:11.654431,  executed if:(op1 != 0B) && (op0 != 0B)
    size:0.500000, time:0.362650,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 0] changed) && (op1 != 0B) && (op0 != 0B)
    size:0.500000, time:0.123301,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 32] changed) && (op1 != 0B) && (op0 != 0B)
    size:0.500000, time:0.041922,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 64] changed) && (op1 != 0B) && (op0 != 0B)
    size:0.500000, time:0.014254,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 96] changed) && (op1 != 0B) && (op0 != 0B)
  calls:
    netif_get_ip6_addr_match.part.0/67 inlined
      loop depth: 0 freq:0.49 size: 4 time: 13callee size:12 stack: 0
      Stack frame offset 0, callee self size 0, callee size 0

IPA function summary for netif_ip6_addr_set_state/27 inlinable
  global time:     13009.668747
  self size:       15
  global size:     38
  min size:       0
  self stack:      0
  global stack:    0
  estimated growth:12
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:1.000000, time:0.700000,  executed if:(op1 <= 2) && (op0 != 0B) && (not inlined)
    size:2.000000, time:7000.008629,  executed if:(op1 > 2) && (op0 != 0B)
    size:2.000000, time:6000.007385,  executed if:(op0 == 0B)
    size:8.000000, time:2.145499,  executed if:(op1 <= 2) && (op0 != 0B)
    size:5.000000, time:0.693000,  executed if:(op1 <= 2) && (op0 != 0B),  nonconst if:(op2 changed) && (op1 <= 2) && (op0 != 0B)
    size:3.500000, time:0.808500,  executed if:(op1 <= 2) && (op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op1 <= 2) && (op0 != 0B)
  calls:
    netif_ip6_addr_set_state.part.0/66 inlined
      loop depth: 0 freq:0.35 size: 4 time: 13callee size:15 stack: 0
      Stack frame offset 0, callee self size 0, callee size 0
      nd6_adjust_mld_membership/54 function body not available
        loop depth: 0 freq:0.08 size: 4 time: 13 predicate: (op1 <= 2) && (op0 != 0B)
      netif_do_ip_addr_changed/9 call is unlikely and code size would grow
        loop depth: 0 freq:0.04 size: 3 time: 12callee size: 6 stack: 0 predicate: (op1 <= 2) && (op0 != 0B)
         op1 is compile time invariant
      netif_issue_reports/20 call is unlikely and code size would grow
        loop depth: 0 freq:0.04 size: 3 time: 12callee size:17 stack: 0 predicate: (op1 <= 2) && (op0 != 0B)
         op1 is compile time invariant

IPA function summary for netif_ip6_addr_set_parts/26 inlinable
  global time:     13017.185577
  self size:       18
  global size:     59
  min size:       0
  self stack:      0
  global stack:    48
  estimated growth:8
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:1.000000, time:0.700000,  executed if:(op1 <= 2) && (op0 != 0B) && (not inlined)
    size:2.000000, time:7000.008629,  executed if:(op1 > 2) && (op0 != 0B)
    size:2.000000, time:6000.007385,  executed if:(op0 == 0B)
    size:37.500000, time:9.122524,  executed if:(op1 <= 2) && (op0 != 0B)
    size:3.000000, time:1.035968,  executed if:(op1 <= 2) && (op0 != 0B),  nonconst if:(op2 changed) && (op1 <= 2) && (op0 != 0B)
    size:1.500000, time:0.176115,  executed if:(op1 <= 2) && (op0 != 0B),  nonconst if:(op0[ref offset: 1808] changed) && (op1 <= 2) && (op0 != 0B)
  calls:
    netif_ip6_addr_set_parts.part.0/65 inlined
      loop depth: 0 freq:0.35 size: 7 time: 16callee size:30 stack:48
      Stack frame offset 0, callee self size 48, callee size 48
      netif_do_ip_addr_changed/9 call is unlikely and code size would grow
        loop depth: 0 freq:0.11 size: 3 time: 12callee size: 6 stack: 0 predicate: (op1 <= 2) && (op0 != 0B)
         op1 is compile time invariant
      netif_issue_reports/20 call is unlikely and code size would grow
        loop depth: 0 freq:0.11 size: 3 time: 12callee size:17 stack: 0 predicate: (op1 <= 2) && (op0 != 0B)
         op1 is compile time invariant

IPA function summary for netif_ip6_addr_set/25 inlinable
  global time:     12525.869141
  self size:       22
  global size:     22
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.400002,  executed if:(op0 != 0B),  nonconst if:(op2 changed) && (op0 != 0B)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op2[ref offset: 0] changed) && (op2 != 0B) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B),  nonconst if:(op2[ref offset: 0] changed) && (op2 != 0B) && (op0 != 0B)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op2[ref offset: 32] changed) && (op2 != 0B) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B),  nonconst if:(op2[ref offset: 32] changed) && (op2 != 0B) && (op0 != 0B)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op2[ref offset: 64] changed) && (op2 != 0B) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B),  nonconst if:(op2[ref offset: 64] changed) && (op2 != 0B) && (op0 != 0B)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op2[ref offset: 96] changed) && (op2 != 0B) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.187145,  executed if:(op2 != 0B) && (op0 != 0B),  nonconst if:(op2[ref offset: 96] changed) && (op2 != 0B) && (op0 != 0B)
    size:1.000000, time:0.748581,  executed if:(op2 != 0B) && (op0 != 0B) && (not inlined)
    size:2.000000, time:6514.218086,  executed if:(op2 == 0B) && (op0 != 0B)
    size:2.000000, time:6000.016663,  executed if:(op0 == 0B)
  calls:
    netif_ip6_addr_set_parts/26 --param max-inline-insns-auto limit reached
      loop depth: 0 freq:0.37 size: 7 time: 16callee size:29 stack:48 predicate: (op2 != 0B) && (op0 != 0B)

IPA function summary for netif_alloc_client_data_id/24 inlinable
  global time:     10006.016983
  self size:       10
  global size:     10
  min size:       0
  self stack:      0
  global stack:    0
    size:7.000000, time:10005.016983
    size:3.000000, time:1.000000,  executed if:(not inlined)
  calls:

IPA function summary for netif_set_link_down/23 inlinable
  global time:     8.914600
  self size:       13
  global size:     13
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.409550,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:4.500000, time:3.276400,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:1.000000, time:0.409550,  executed if:(op0 != 0B) && (not inlined)
    size:1.000000, time:0.409550,  executed if:(op0 != 0B)
    size:0.500000, time:0.204775,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1696] changed) && (op0 != 0B) && (not inlined)
    size:0.500000, time:0.204775,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1696] changed) && (op0 != 0B)
  calls:

IPA function summary for netif_set_link_up/22 inlinable
  global time:     14.033975
  self size:       16
  global size:     16
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.409550,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:4.500000, time:3.137153,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:0.500000, time:0.135151,  executed if:(op0 != 0B) && (not inlined)
    size:0.500000, time:0.135151,  executed if:(op0 != 0B)
  calls:
    nd6_restart_netif/41 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)
    netif_issue_reports/20 call is unlikely and code size would grow
      loop depth: 0 freq:0.27 size: 3 time: 12callee size:17 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant

IPA function summary for netif_set_down/21 inlinable
  global time:     16.366690
  self size:       23
  global size:     23
  min size:       0
  self stack:      0
  global stack:    0
  estimated growth:16
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.409550,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:4.500000, time:3.137153,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:1.500000, time:0.405454,  executed if:(op0 != 0B) && (not inlined)
    size:5.500000, time:1.486666,  executed if:(op0 != 0B)
  calls:
    nd6_cleanup_netif/53 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)
    etharp_cleanup_netif/52 function body not available
      loop depth: 0 freq:0.09 size: 2 time: 11 predicate: (op0 != 0B)
    sys_now/51 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)

IPA function summary for netif_issue_reports/20 inlinable
  global time:     6011.387924
  self size:       32
  global size:     34
  min size:       0
  self stack:      0
  global stack:    0
  estimated growth:78
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.350000,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:6.500000, time:2.712496,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:6.000000, time:2.100008,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:2.000000, time:1.531249,  executed if:(op0 != 0B) && (not inlined)
    size:6.000000, time:0.743748,  executed if:(op0 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op0 == 0B)
  calls:
    netif_issue_reports.part.0/60 inlined
      loop depth: 0 freq:0.35 size: 3 time: 12callee size: 4 stack: 0
      Stack frame offset 0, callee self size 0, callee size 0
      mld6_report_groups/48 function body not available
        loop depth: 0 freq:0.12 size: 2 time: 11 predicate: (op0 != 0B)
    igmp_report_groups/47 function body not available
      loop depth: 0 freq:0.03 size: 2 time: 11 predicate: (op0 != 0B)
    etharp_request/46 function body not available
      loop depth: 0 freq:0.03 size: 3 time: 12 predicate: (op0 != 0B)

IPA function summary for netif_set_up/19 inlinable
  global time:     17.547914
  self size:       20
  global size:     20
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:0.500000, time:0.409550,  executed if:(op0 != 0B) && (not inlined),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B) && (not inlined)
    size:4.500000, time:3.137153,  executed if:(op0 != 0B),  nonconst if:(op0[ref offset: 1784] changed) && (op0 != 0B)
    size:1.000000, time:0.270303,  executed if:(op0 != 0B) && (not inlined)
    size:2.000000, time:0.540606,  executed if:(op0 != 0B)
  calls:
    nd6_restart_netif/41 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)
    netif_issue_reports/20 call is unlikely and code size would grow
      loop depth: 0 freq:0.27 size: 3 time: 12callee size:17 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant
    sys_now/51 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)

IPA function summary for netif_set_default/18 inlinable
  global time:     3.000000
  self size:       4
  global size:     4
  min size:       0
  self stack:      0
  global stack:    0
    size:1.000000, time:1.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:

IPA function summary for netif_remove/17 inlinable
  global time:     91.085433
  self size:       50
  global size:     50
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:3.000000, time:2.719454,  executed if:(op0 != 0B) && (not inlined)
    size:30.000000, time:56.434669,  executed if:(op0 != 0B)
  calls:
    netif_set_down/21 call is unlikely and code size would grow
      loop depth: 0 freq:0.27 size: 2 time: 11callee size:11 stack: 0 predicate: (op0 != 0B)
    mld6_stop/50 function body not available
      loop depth: 0 freq:0.82 size: 2 time: 11 predicate: (op0 != 0B)
    netif_do_ip_addr_changed/9 call is unlikely and code size would grow
      loop depth: 1 freq:0.81 size: 3 time: 12callee size: 6 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant
    igmp_stop/49 function body not available
      loop depth: 0 freq:0.27 size: 2 time: 11 predicate: (op0 != 0B)
    netif_do_ip_addr_changed/9 call is unlikely and code size would grow
      loop depth: 0 freq:0.27 size: 3 time: 12callee size: 6 stack: 0 predicate: (op0 != 0B)
       op1 is compile time invariant

IPA function summary for netif_set_addr/16 inlinable
  global time:     36.400050
  self size:       36
  global size:     36
  min size:       16
  self stack:      24
  global stack:    24
  estimated growth:25
    size:16.000000, time:14.477100
    size:6.000000, time:4.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op1 changed)
    size:2.000000, time:2.000000,  nonconst if:(op2 changed)
    size:2.000000, time:2.000000,  nonconst if:(op3 changed)
  calls:
    netif_do_set_ipaddr/10 call is unlikely and code size would grow
      loop depth: 0 freq:0.33 size: 4 time: 13callee size:17 stack:24
       op2 is compile time invariant
    netif_do_set_ipaddr/10 call is unlikely and code size would grow
      loop depth: 0 freq:0.59 size: 4 time: 13callee size:17 stack:24
       op2 is compile time invariant

IPA function summary for netif_set_gw/15 inlinable
  global time:     9.733700
  self size:       13
  global size:     13
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.638200,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:4.500000, time:3.276400,  executed if:(op0 != 0B)
    size:1.500000, time:0.819100,  executed if:(op0 != 0B) && (not inlined)
  calls:

IPA function summary for netif_set_netmask/13 inlinable
  global time:     9.733700
  self size:       13
  global size:     13
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.638200,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:4.500000, time:3.276400,  executed if:(op0 != 0B)
    size:1.500000, time:0.819100,  executed if:(op0 != 0B) && (not inlined)
  calls:

IPA function summary for netif_set_ipaddr/11 inlinable
  global time:     16.286500
  self size:       11
  global size:     11
  min size:       0
  self stack:      24
  global stack:    24
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.638200,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
  calls:
    netif_do_set_ipaddr/10 call is unlikely and code size would grow
      loop depth: 0 freq:0.82 size: 4 time: 13callee size:17 stack:24 predicate: (op0 != 0B)
       op2 is compile time invariant

IPA function summary for netif_do_set_ipaddr/10 inlinable
  global time:     10214.495987
  self size:       16
  global size:     35
  min size:       0
  self stack:      0
  global stack:    24
  estimated growth:5
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op1 changed)
    size:2.000000, time:1.399999,  executed if:(op1 != 0B),  nonconst if:(op2 changed) && (op1 != 0B)
    size:1.000000, time:0.980004,  executed if:(op2 != 0B) && (op1 != 0B) && (not inlined)
    size:2.000000, time:4200.011055,  executed if:(op2 == 0B) && (op1 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op1 == 0B)
    size:17.500000, time:3.964114,  executed if:(op2 != 0B) && (op1 != 0B)
    size:0.500000, time:0.245001,  executed if:(op2 != 0B) && (op1 != 0B),  nonconst if:(op1[ref offset: 0] changed) && (op2 != 0B) && (op1 != 0B)
  calls:
    netif_do_set_ipaddr.part.0/61 inlined
      loop depth: 0 freq:0.49 size: 5 time: 14callee size:19 stack:24
      Stack frame offset 0, callee self size 24, callee size 24
      netif_do_ip_addr_changed/9 call is unlikely and code size would grow
        loop depth: 0 freq:0.25 size: 3 time: 12callee size: 6 stack: 0 predicate: (op2 != 0B) && (op1 != 0B)
         op1 is compile time invariant
      netif_issue_reports/20 call is unlikely and code size would grow
        loop depth: 0 freq:0.25 size: 3 time: 12callee size:17 stack: 0 predicate: (op2 != 0B) && (op1 != 0B)
         op1 is compile time invariant

IPA function summary for netif_do_ip_addr_changed/9 inlinable
  global time:     38.000000
  self size:       12
  global size:     12
  min size:       0
  self stack:      0
  global stack:    0
  estimated growth:18
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:
    raw_netif_ip_addr_changed/45 function body not available
      loop depth: 0 freq:1.00 size: 3 time: 12
    udp_netif_ip_addr_changed/44 function body not available
      loop depth: 0 freq:1.00 size: 3 time: 12
    tcp_netif_ip_addr_changed/43 function body not available
      loop depth: 0 freq:1.00 size: 3 time: 12

IPA function summary for netif_add/8 inlinable
  global time:     13527.869797
  self size:       113
  global size:     113
  min size:       0
  self stack:      0
  global stack:    0
  estimated growth:72
    size:0.000000, time:0.000000
    size:3.000000, time:0.680637,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.834600,  executed if:(op0 != 0B),  nonconst if:(op5 changed) && (op0 != 0B)
    size:2.000000, time:1.682879,  executed if:(op5 != 0B) && (op0 != 0B),  nonconst if:(op1 changed) && (op5 != 0B) && (op0 != 0B)
    size:2.000000, time:1.682879,  executed if:(op5 != 0B) && (op0 != 0B),  nonconst if:(op2 changed) && (op5 != 0B) && (op0 != 0B)
    size:2.000000, time:1.682879,  executed if:(op5 != 0B) && (op0 != 0B),  nonconst if:(op3 changed) && (op5 != 0B) && (op0 != 0B)
    size:23.000000, time:33.745675,  executed if:(op5 != 0B) && (op0 != 0B) && (not inlined)
    size:59.000000, time:13438.152161,  executed if:(op5 != 0B) && (op0 != 0B)
  calls:
    igmp_start/42 function body not available
      loop depth: 0 freq:0.01 size: 2 time: 11 predicate: (op5 != 0B) && (op0 != 0B)
    netif_set_addr/16 call is unlikely and code size would grow
      loop depth: 0 freq:0.84 size: 5 time: 14callee size:18 stack:24 predicate: (op5 != 0B) && (op0 != 0B)
    nd6_restart_netif/41 function body not available
      loop depth: 0 freq:0.84 size: 2 time: 11 predicate: (op5 != 0B) && (op0 != 0B)
    memset/40 function body not available
      loop depth: 0 freq:0.84 size: 4 time: 13 predicate: (op5 != 0B) && (op0 != 0B)
       op1 is compile time invariant
       op2 is compile time invariant
    indirect call loop depth: 0 freq:0.84 size: 5 time: 17predicate: (op5 != 0B) && (op0 != 0B)

IPA function summary for netif_add_noaddr/7 inlinable
  global time:     20.000000
  self size:       12
  global size:     12
  min size:       18
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:
    netif_add/8 --param max-inline-insns-auto limit reached
      loop depth: 0 freq:1.00 size: 9 time: 18callee size:56 stack: 0
       op1 is compile time invariant
       op2 is compile time invariant
       op3 is compile time invariant

IPA function summary for netif_input/6 inlinable
  global time:     10212.736877
  self size:       23
  global size:     23
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:2.000000, time:0.000000,  executed if:(not inlined)
    size:2.000000, time:2.000000,  nonconst if:(op0 changed)
    size:2.000000, time:1.399999,  executed if:(op0 != 0B),  nonconst if:(op1 changed) && (op0 != 0B)
    size:0.500000, time:0.245001,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined),  nonconst if:(op1[ref offset: 1784] changed) && (op1 != 0B) && (op0 != 0B) && (not inlined)
    size:3.500000, time:1.715006,  executed if:(op1 != 0B) && (op0 != 0B),  nonconst if:(op1[ref offset: 1784] changed) && (op1 != 0B) && (op0 != 0B)
    size:1.000000, time:0.980004,  executed if:(op1 != 0B) && (op0 != 0B) && (not inlined)
    size:2.000000, time:4200.011055,  executed if:(op1 == 0B) && (op0 != 0B)
    size:2.000000, time:6000.015778,  executed if:(op0 == 0B)
  calls:
    ip_input/38 function body not available
      loop depth: 0 freq:0.25 size: 4 time: 13 predicate: (op1 != 0B) && (op0 != 0B)
    ethernet_input/37 function body not available
      loop depth: 0 freq:0.25 size: 4 time: 13 predicate: (op1 != 0B) && (op0 != 0B)

IPA function summary for netif_init/5 inlinable
  global time:     2.000000
  self size:       3
  global size:     3
  min size:       0
  self stack:      0
  global stack:    0
    size:0.000000, time:0.000000
    size:3.000000, time:2.000000,  executed if:(not inlined)
  calls:

Symbol table:

netif_null_output_ip6.constprop.0/68 (netif_null_output_ip6.constprop) @06da8ee0
  Type: function definition analyzed
  Visibility:
  References: 
  Referring: 
  Function netif_null_output_ip6.constprop/68 is inline copy in netif_null_output_ip4/32
  Clone of netif_null_output_ip6/31
  Availability: local
  Function flags: count:1073741824 (estimated locally) local icf_merged optimize_size
  Called by: netif_null_output_ip4/32 (inlined) (1073741824 (estimated locally),1.00 per call) 
  Calls: 
netif_get_ip6_addr_match.part.0/67 (netif_get_ip6_addr_match.part.0) @06fd2000
  Type: function definition analyzed
  Visibility: prevailing_def_ironly artificial
  References: 
  Referring: 
  Function netif_get_ip6_addr_match.part.0/67 is inline copy in netif_get_ip6_addr_match/28
  Availability: local
  Function flags: count:173624 (estimated locally) first_run:1 body local split_part optimize_size
  Called by: netif_get_ip6_addr_match/28 (inlined) (173624 (estimated locally),0.49 per call) 
  Calls: 
netif_ip6_addr_set_state.part.0/66 (netif_ip6_addr_set_state.part.0) @06f200e0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly artificial
  References: 
  Referring: 
  Function netif_ip6_addr_set_state.part.0/66 is inline copy in netif_ip6_addr_set_state/27
  Availability: local
  Function flags: count:107374 (estimated locally) first_run:1 body local split_part optimize_size
  Called by: netif_ip6_addr_set_state/27 (inlined) (107374 (estimated locally),0.35 per call) 
  Calls: nd6_adjust_mld_membership/54 (23386 (estimated locally),0.08 per call) netif_do_ip_addr_changed/9 (11693 (estimated locally),0.04 per call) netif_issue_reports/20 (11693 (estimated locally),0.04 per call) 
netif_ip6_addr_set_parts.part.0/65 (netif_ip6_addr_set_parts.part.0) @06b528c0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly artificial
  References: 
  Referring: 
  Function netif_ip6_addr_set_parts.part.0/65 is inline copy in netif_ip6_addr_set_parts/26
  Availability: local
  Function flags: count:107374 (estimated locally) first_run:1 body local split_part optimize_size
  Called by: netif_ip6_addr_set_parts/26 (inlined) (107374 (estimated locally),0.35 per call) 
  Calls: netif_do_ip_addr_changed/9 (34960 (estimated locally),0.11 per call) netif_issue_reports/20 (34960 (estimated locally),0.11 per call) 
netif_do_set_ipaddr.part.0/61 (netif_do_set_ipaddr.part.0) @06f20ee0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly artificial
  References: 
  Referring: 
  Function netif_do_set_ipaddr.part.0/61 is inline copy in netif_do_set_ipaddr/10
  Availability: local
  Function flags: count:175378 (estimated locally) first_run:1 body local split_part optimize_size
  Called by: netif_do_set_ipaddr/10 (inlined) (175378 (estimated locally),0.49 per call) 
  Calls: netif_do_ip_addr_changed/9 (87689 (estimated locally),0.25 per call) netif_issue_reports/20 (87689 (estimated locally),0.25 per call) 
netif_issue_reports.part.0/60 (netif_issue_reports.part.0) @06f207e0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly artificial
  References: 
  Referring: 
  Function netif_issue_reports.part.0/60 is inline copy in netif_issue_reports/20
  Availability: local
  Function flags: count:125270 (estimated locally) first_run:1 body local split_part optimize_size
  Called by: netif_issue_reports/20 (inlined) (125270 (estimated locally),0.35 per call) 
  Calls: mld6_report_groups/48 (41339 (estimated locally),0.12 per call) 
atoi/57 (atoi) @06ea3ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_find/36 (76616578 (estimated locally),0.85 per call) 
  Calls: 
lwip_itoa/56 (lwip_itoa) @06ea3c40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_index_to_name/34 (635440412 (estimated locally),0.59 per call) 
  Calls: 
lwip_htonl/55 (lwip_htonl) @06ea37e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_create_ip6_linklocal_address/29 (881341 (estimated locally),2.46 per call) netif_create_ip6_linklocal_address/29 (82678 (estimated locally),0.23 per call) netif_create_ip6_linklocal_address/29 (82678 (estimated locally),0.23 per call) 
  Calls: 
nd6_adjust_mld_membership/54 (nd6_adjust_mld_membership) @06ea3460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_ip6_addr_set_state.part.0/66 (23386 (estimated locally),0.08 per call) 
  Calls: 
nd6_cleanup_netif/53 (nd6_cleanup_netif) @06e6cd20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_set_down/21 (290235636 (estimated locally),0.27 per call) 
  Calls: 
etharp_cleanup_netif/52 (etharp_cleanup_netif) @06e6cc40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_set_down/21 (95777760 (estimated locally),0.09 per call) 
  Calls: 
sys_now/51 (sys_now) @06e6ca80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_set_down/21 (290235636 (estimated locally),0.27 per call) netif_set_up/19 (290235636 (estimated locally),0.27 per call) 
  Calls: 
mld6_stop/50 (mld6_stop) @06e6c7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_remove/17 (164090760 (estimated locally),0.82 per call) 
  Calls: 
igmp_stop/49 (igmp_stop) @06e6c700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_remove/17 (54149951 (estimated locally),0.27 per call) 
  Calls: 
mld6_report_groups/48 (mld6_report_groups) @06e19ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_issue_reports.part.0/60 (41339 (estimated locally),0.12 per call) 
  Calls: 
igmp_report_groups/47 (igmp_report_groups) @06e19e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_issue_reports/20 (10335 (estimated locally),0.03 per call) 
  Calls: 
etharp_request/46 (etharp_request) @06e19d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_issue_reports/20 (10335 (estimated locally),0.03 per call) 
  Calls: 
raw_netif_ip_addr_changed/45 (raw_netif_ip_addr_changed) @06e19b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_do_ip_addr_changed/9 (1073741824 (estimated locally),1.00 per call) 
  Calls: 
udp_netif_ip_addr_changed/44 (udp_netif_ip_addr_changed) @06e19a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_do_ip_addr_changed/9 (1073741824 (estimated locally),1.00 per call) 
  Calls: 
tcp_netif_ip_addr_changed/43 (tcp_netif_ip_addr_changed) @06e199a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_do_ip_addr_changed/9 (1073741824 (estimated locally),1.00 per call) 
  Calls: 
igmp_start/42 (igmp_start) @06e19460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_add/8 (2582 (estimated locally),0.01 per call) 
  Calls: 
nd6_restart_netif/41 (nd6_restart_netif) @06e192a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_set_link_up/22 (290235636 (estimated locally),0.27 per call) netif_set_up/19 (290235636 (estimated locally),0.27 per call) netif_add/8 (185391 (estimated locally),0.84 per call) 
  Calls: 
memset/40 (memset) @06e191c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_add/8 (185391 (estimated locally),0.84 per call) 
  Calls: 
ip_addr_any/39 (ip_addr_any) @06e1a0d8
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: netif_set_addr/16 (addr)netif_set_addr/16 (addr)netif_set_gw/15 (addr)netif_set_netmask/13 (addr)netif_set_addr/16 (addr)netif_set_ipaddr/11 (addr)netif_add/8 (addr)netif_add/8 (addr)netif_add/8 (addr)
  Availability: not_available
  Varpool flags: read-only
ip_input/38 (ip_input) @06e09380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_input/6 (87689 (estimated locally),0.25 per call) 
  Calls: 
ethernet_input/37 (ethernet_input) @06e090e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_input/6 (87689 (estimated locally),0.25 per call) 
  Calls: 
netif_find/36 (netif_find) @06e09a80
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_list/1 (read)
  Referring: 
  Availability: available
  Function flags: count:90638327 (estimated locally) body optimize_size
  Called by: netif_name_to_index/33 (1073741824 (estimated locally),1.00 per call) 
  Calls: atoi/57 (76616578 (estimated locally),0.85 per call) 
netif_get_by_index/35 (netif_get_by_index) @06e097e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_list/1 (read)
  Referring: 
  Availability: available
  Function flags: count:161779623 (estimated locally) body optimize_size
  Called by: netif_index_to_name/34 (1073741824 (estimated locally),1.00 per call) 
  Calls: 
netif_index_to_name/34 (netif_index_to_name) @06e09540
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: lwip_itoa/56 (635440412 (estimated locally),0.59 per call) netif_get_by_index/35 (1073741824 (estimated locally),1.00 per call) 
netif_name_to_index/33 (netif_name_to_index) @06e092a0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: netif_find/36 (1073741824 (estimated locally),1.00 per call) 
netif_null_output_ip4/32 (netif_null_output_ip4) @06e09000
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: 
  Referring: netif_add/8 (addr)
  Availability: available
  Function flags: count:1073741824 (estimated locally) body icf_merged optimize_size
  Called by: 
  Calls: netif_null_output_ip6.constprop/68 (inlined) (1073741824 (estimated locally),1.00 per call) 
netif_null_output_ip6/31 (netif_null_output_ip6) @06ded700
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: 
  Referring: netif_add/8 (addr)
  Availability: available
  Function flags: count:1073741824 (estimated locally) body icf_merged optimize_size
  Called by: 
  Calls: 
netif_add_ip6_address/30 (netif_add_ip6_address) @06dedd20
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:329661 (estimated locally) body optimize_size
  Called by: 
  Calls: netif_ip6_addr_set_state/27 (34429 (estimated locally),0.10 per call) netif_get_ip6_addr_match/28 (123389 (estimated locally),0.37 per call) 
netif_create_ip6_linklocal_address/29 (netif_create_ip6_linklocal_address) @06ded620
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:357913 (estimated locally) body optimize_size
  Called by: 
  Calls: netif_ip6_addr_set_state/27 (250539 (estimated locally),0.70 per call) lwip_htonl/55 (881341 (estimated locally),2.46 per call) lwip_htonl/55 (82678 (estimated locally),0.23 per call) lwip_htonl/55 (82678 (estimated locally),0.23 per call) 
netif_get_ip6_addr_match/28 (netif_get_ip6_addr_match) @06de7ee0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:357913 (estimated locally) body optimize_size
  Called by: netif_add_ip6_address/30 (123389 (estimated locally),0.37 per call) 
  Calls: netif_get_ip6_addr_match.part.0/67 (inlined) (173624 (estimated locally),0.49 per call) 
netif_ip6_addr_set_state/27 (netif_ip6_addr_set_state) @06de78c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:306783 (estimated locally) body optimize_size
  Called by: netif_add_ip6_address/30 (34429 (estimated locally),0.10 per call) netif_create_ip6_linklocal_address/29 (250539 (estimated locally),0.70 per call) 
  Calls: netif_ip6_addr_set_state.part.0/66 (inlined) (107374 (estimated locally),0.35 per call) 
netif_ip6_addr_set_parts/26 (netif_ip6_addr_set_parts) @06de7540
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:306783 (estimated locally) body optimize_size
  Called by: netif_ip6_addr_set/25 (123389 (estimated locally),0.37 per call) 
  Calls: netif_ip6_addr_set_parts.part.0/65 (inlined) (107374 (estimated locally),0.35 per call) 
netif_ip6_addr_set/25 (netif_ip6_addr_set) @06dc17e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:329661 (estimated locally) body optimize_size
  Called by: 
  Calls: netif_ip6_addr_set_parts/26 (123389 (estimated locally),0.37 per call) 
netif_alloc_client_data_id/24 (netif_alloc_client_data_id) @06dc1540
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_client_id/4 (read)netif_client_id/4 (write)
  Referring: 
  Availability: available
  Function flags: count:214748 (estimated locally) body optimize_size
  Called by: 
  Calls: 
netif_set_link_down/23 (netif_set_link_down) @06dc12a0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: 
netif_set_link_up/22 (netif_set_link_up) @06dc1000
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: nd6_restart_netif/41 (290235636 (estimated locally),0.27 per call) netif_issue_reports/20 (290235636 (estimated locally),0.27 per call) 
netif_set_down/21 (netif_set_down) @06db78c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: netif_remove/17 (54149951 (estimated locally),0.27 per call) 
  Calls: nd6_cleanup_netif/53 (290235636 (estimated locally),0.27 per call) etharp_cleanup_netif/52 (95777760 (estimated locally),0.09 per call) sys_now/51 (290235636 (estimated locally),0.27 per call) 
netif_issue_reports/20 (netif_issue_reports) @06db7e00
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: count:357913 (estimated locally) body local optimize_size
  Called by: netif_ip6_addr_set_state.part.0/66 (11693 (estimated locally),0.04 per call) netif_ip6_addr_set_parts.part.0/65 (34960 (estimated locally),0.11 per call) netif_set_link_up/22 (290235636 (estimated locally),0.27 per call) netif_set_up/19 (290235636 (estimated locally),0.27 per call) netif_do_set_ipaddr.part.0/61 (87689 (estimated locally),0.25 per call) 
  Calls: netif_issue_reports.part.0/60 (inlined) (125270 (estimated locally),0.35 per call) igmp_report_groups/47 (10335 (estimated locally),0.03 per call) etharp_request/46 (10335 (estimated locally),0.03 per call) 
netif_set_up/19 (netif_set_up) @06db77e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: nd6_restart_netif/41 (290235636 (estimated locally),0.27 per call) netif_issue_reports/20 (290235636 (estimated locally),0.27 per call) sys_now/51 (290235636 (estimated locally),0.27 per call) 
netif_set_default/18 (netif_set_default) @06db7460
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_default/2 (write)
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: 
netif_remove/17 (netif_remove) @06db71c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_default/2 (read)netif_default/2 (write)netif_list/1 (read)netif_list/1 (write)
  Referring: 
  Availability: available
  Function flags: count:200330558 (estimated locally) body optimize_size
  Called by: 
  Calls: netif_set_down/21 (54149951 (estimated locally),0.27 per call) mld6_stop/50 (164090760 (estimated locally),0.82 per call) netif_do_ip_addr_changed/9 (162449853 (estimated locally),0.81 per call) igmp_stop/49 (54149951 (estimated locally),0.27 per call) netif_do_ip_addr_changed/9 (54149951 (estimated locally),0.27 per call) 
netif_set_addr/16 (netif_set_addr) @06db1c40
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)ip_addr_any/39 (addr)ip_addr_any/39 (addr)
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: netif_add/8 (185391 (estimated locally),0.84 per call) 
  Calls: netif_do_set_ipaddr/10 (354334802 (estimated locally),0.33 per call) netif_do_set_ipaddr/10 (630447513 (estimated locally),0.59 per call) 
netif_set_gw/15 (netif_set_gw) @06db18c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: 
netif_set_netmask/13 (netif_set_netmask) @06db1000
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: 
netif_set_ipaddr/11 (netif_set_ipaddr) @06da88c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: netif_do_set_ipaddr/10 (879501928 (estimated locally),0.82 per call) 
netif_do_set_ipaddr/10 (netif_do_set_ipaddr) @06da8620
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: count:357913 (estimated locally) body local optimize_size
  Called by: netif_set_addr/16 (354334802 (estimated locally),0.33 per call) netif_set_addr/16 (630447513 (estimated locally),0.59 per call) netif_set_ipaddr/11 (879501928 (estimated locally),0.82 per call) 
  Calls: netif_do_set_ipaddr.part.0/61 (inlined) (175378 (estimated locally),0.49 per call) 
netif_do_ip_addr_changed/9 (netif_do_ip_addr_changed) @06d7c8c0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: count:1073741824 (estimated locally) body local optimize_size
  Called by: netif_ip6_addr_set_state.part.0/66 (11693 (estimated locally),0.04 per call) netif_ip6_addr_set_parts.part.0/65 (34960 (estimated locally),0.11 per call) netif_remove/17 (162449853 (estimated locally),0.81 per call) netif_remove/17 (54149951 (estimated locally),0.27 per call) netif_do_set_ipaddr.part.0/61 (87689 (estimated locally),0.25 per call) 
  Calls: raw_netif_ip_addr_changed/45 (1073741824 (estimated locally),1.00 per call) udp_netif_ip_addr_changed/44 (1073741824 (estimated locally),1.00 per call) tcp_netif_ip_addr_changed/43 (1073741824 (estimated locally),1.00 per call) 
netif_add/8 (netif_add) @06d7c620
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)ip_addr_any/39 (addr)netif_null_output_ip4/32 (addr)ip_addr_any/39 (addr)netif_null_output_ip6/31 (addr)netif_num/3 (read)netif_list/1 (read)netif_num/3 (write)netif_num/3 (write)netif_list/1 (write)
  Referring: 
  Availability: available
  Function flags: count:220326 (estimated locally) body optimize_size
  Called by: netif_add_noaddr/7 (1073741824 (estimated locally),1.00 per call) 
  Calls: igmp_start/42 (2582 (estimated locally),0.01 per call) netif_set_addr/16 (185391 (estimated locally),0.84 per call) nd6_restart_netif/41 (185391 (estimated locally),0.84 per call) memset/40 (185391 (estimated locally),0.84 per call) 
   Indirect call(185391 (estimated locally),0.84 per call)  of param:5 (vptr maybe changed)
netif_add_noaddr/7 (netif_add_noaddr) @06d61d20
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: netif_add/8 (1073741824 (estimated locally),1.00 per call) 
netif_input/6 (netif_input) @06d61ee0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:357913 (estimated locally) body optimize_size
  Called by: 
  Calls: ip_input/38 (87689 (estimated locally),0.25 per call) ethernet_input/37 (87689 (estimated locally),0.25 per call) 
netif_init/5 (netif_init) @06d61c40
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: count:1073741824 (estimated locally) body optimize_size
  Called by: 
  Calls: 
netif_client_id/4 (netif_client_id) @06d5ad80
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: netif_alloc_client_data_id/24 (read)netif_alloc_client_data_id/24 (write)
  Availability: available
  Varpool flags:
netif_num/3 (netif_num) @06d5acf0
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: netif_add/8 (read)netif_add/8 (write)netif_add/8 (write)
  Availability: available
  Varpool flags:
netif_default/2 (netif_default) @06d5ac18
  Type: variable definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: netif_set_default/18 (write)netif_remove/17 (read)netif_remove/17 (write)
  Availability: available
  Varpool flags:
netif_list/1 (netif_list) @06d5abd0
  Type: variable definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: netif_get_by_index/35 (read)netif_add/8 (write)netif_remove/17 (write)netif_add/8 (read)netif_remove/17 (read)netif_find/36 (read)
  Availability: available
  Varpool flags:

;; Function netif_null_output_ip6 (netif_null_output_ip6, funcdef_no=27, decl_uid=7828, cgraph_uid=28, symbol_order=31)

netif_null_output_ip6 (struct netif * netif, struct pbuf * p, const struct ip6_addr_t * ipaddr)
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  return -12;

}



;; Function netif_do_ip_addr_changed (netif_do_ip_addr_changed, funcdef_no=5, decl_uid=7872, cgraph_uid=6, symbol_order=9)

netif_do_ip_addr_changed (const struct ip_addr_t * old_addr, const struct ip_addr_t * new_addr)
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  tcp_netif_ip_addr_changed (old_addr_2(D), new_addr_3(D));
  # DEBUG BEGIN_STMT
  udp_netif_ip_addr_changed (old_addr_2(D), new_addr_3(D));
  # DEBUG BEGIN_STMT
  raw_netif_ip_addr_changed (old_addr_2(D), new_addr_3(D));
  return;

}



;; Function netif_issue_reports (netif_issue_reports, funcdef_no=16, decl_uid=7824, cgraph_uid=17, symbol_order=20)


Symbols to be put in SSA form
{ D.8370 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 20
Number of blocks to update: 19 ( 95%)


Merging blocks 3 and 14
Merging blocks 11 and 16
Removing basic block 13
Removing basic block 15
Merging blocks 11 and 17
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;;
;; Loop 1
;;  header 3, latch 3
;;  depth 1, outer 0
;;  nodes: 3
;; 2 succs { 3 4 }
;; 3 succs { 3 }
;; 4 succs { 14 5 }
;; 5 succs { 6 11 }
;; 6 succs { 7 11 }
;; 7 succs { 8 9 }
;; 8 succs { 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 14 }
;; 14 succs { 1 }
netif_issue_reports (struct netif * netif, u8_t report_type)
{
  unsigned char _1;
  long unsigned int _4;
  struct ip4_addr_t * _5;
  unsigned char _6;
  unsigned char _16;
  unsigned char _17;
  unsigned char _18;
  unsigned char _19;
  unsigned char _20;

  <bb 2> [local count: 357913]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_10(D) == 0B)
    goto <bb 3>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 3> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 250539]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif_10(D)->flags;
  _16 = _1 & 5;
  if (_16 != 5)
    goto <bb 14>; [50.00%]
  else
    goto <bb 5>; [50.00%]

  <bb 5> [local count: 125270]:
  # DEBUG BEGIN_STMT
  _17 = report_type_12(D) & 1;
  if (_17 != 0)
    goto <bb 6>; [50.00%]
  else
    goto <bb 11>; [50.00%]

  <bb 6> [local count: 62635]:
  _4 = MEM[(const struct ip4_addr_t *)netif_10(D) + 4B].addr;
  if (_4 != 0)
    goto <bb 7>; [50.00%]
  else
    goto <bb 11>; [50.00%]

  <bb 7> [local count: 31317]:
  # DEBUG BEGIN_STMT
  _18 = _1 & 8;
  if (_18 != 0)
    goto <bb 8>; [33.00%]
  else
    goto <bb 9>; [67.00%]

  <bb 8> [local count: 10335]:
  # DEBUG BEGIN_STMT
  _5 = &netif_10(D)->ip_addr.u_addr.ip4;
  etharp_request (netif_10(D), _5);

  <bb 9> [local count: 31317]:
  # DEBUG BEGIN_STMT
  _6 = netif_10(D)->flags;
  _19 = _6 & 32;
  if (_19 != 0)
    goto <bb 10>; [33.00%]
  else
    goto <bb 11>; [67.00%]

  <bb 10> [local count: 10335]:
  # DEBUG BEGIN_STMT
  igmp_report_groups (netif_10(D));

  <bb 11> [local count: 125270]:
  # DEBUG netif => netif_10(D)
  # DEBUG report_type => report_type_12(D)
  # DEBUG INLINE_ENTRY netif_issue_reports
  # DEBUG BEGIN_STMT
  _20 = report_type_12(D) & 2;
  if (_20 != 0)
    goto <bb 12>; [33.00%]
  else
    goto <bb 13>; [67.00%]

  <bb 12> [local count: 41339]:
  # DEBUG BEGIN_STMT
  mld6_report_groups (netif_10(D));

  <bb 13> [local count: 125270]:

  <bb 14> [local count: 250539]:
  # DEBUG netif => NULL
  # DEBUG report_type => NULL
  return;

}



;; Function netif_do_set_ipaddr (netif_do_set_ipaddr, funcdef_no=6, decl_uid=7877, cgraph_uid=7, symbol_order=10)


Symbols to be put in SSA form
{ D.8371 D.8536 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 19
Number of blocks to update: 18 ( 95%)


Merging blocks 3 and 9
Merging blocks 5 and 10
Removing basic block 6
Removing basic block 7
Removing basic block 8
Removing basic block 12
Merging blocks 18 and 11
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 2
;;  header 3, latch 3
;;  depth 1, outer 0
;;  nodes: 3
;;
;; Loop 1
;;  header 5, latch 5
;;  depth 1, outer 0
;;  nodes: 5
;; 2 succs { 3 4 }
;; 3 succs { 3 }
;; 4 succs { 5 6 }
;; 5 succs { 5 }
;; 6 succs { 7 11 }
;; 7 succs { 8 9 }
;; 8 succs { 10 }
;; 9 succs { 10 }
;; 10 succs { 11 }
;; 11 succs { 1 }
netif_do_set_ipaddr (struct netif * netif, const struct ip4_addr_t * ipaddr, struct ip_addr_t * old_addr)
{
  struct ip_addr_t new_addr;
  int D.8536;
  int _2;
  long unsigned int _11;
  long unsigned int _12;
  unsigned char _13;
  unsigned char _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  unsigned char _18;
  long unsigned int iftmp.4_19;
  int _20;

  <bb 2> [local count: 357913]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr_5(D) == 0B)
    goto <bb 3>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 3> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 250539]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (old_addr_7(D) == 0B)
    goto <bb 5>; [30.00%]
  else
    goto <bb 6>; [70.00%]

  <bb 5> [local count: 751619279]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [100.00%]

  <bb 6> [local count: 175378]:
  # DEBUG netif => netif_8(D)
  # DEBUG ipaddr => ipaddr_5(D)
  # DEBUG old_addr => old_addr_7(D)
  # DEBUG INLINE_ENTRY netif_do_set_ipaddr
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _11 = ipaddr_5(D)->addr;
  _12 = MEM[(const struct ip4_addr_t *)netif_8(D) + 4B].addr;
  if (_11 != _12)
    goto <bb 7>; [50.00%]
  else
    goto <bb 11>; [50.00%]

  <bb 7> [local count: 87689]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_addr.u_addr.ip4 = *ipaddr_5(D);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_addr.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _13 = MEM[(const struct ip_addr_t *)netif_8(D) + 4B].type;
  old_addr_7(D)->type = _13;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _14 = MEM[(const struct ip_addr_t *)netif_8(D) + 4B].type;
  if (_14 == 6)
    goto <bb 8>; [34.00%]
  else
    goto <bb 9>; [66.00%]

  <bb 8> [local count: 29814]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  old_addr_7(D)->u_addr.ip6.addr[0] = _12;
  # DEBUG BEGIN_STMT
  _15 = MEM[(const struct ip_addr_t *)netif_8(D) + 4B].u_addr.ip6.addr[1];
  old_addr_7(D)->u_addr.ip6.addr[1] = _15;
  # DEBUG BEGIN_STMT
  _16 = MEM[(const struct ip_addr_t *)netif_8(D) + 4B].u_addr.ip6.addr[2];
  old_addr_7(D)->u_addr.ip6.addr[2] = _16;
  # DEBUG BEGIN_STMT
  _17 = MEM[(const struct ip_addr_t *)netif_8(D) + 4B].u_addr.ip6.addr[3];
  old_addr_7(D)->u_addr.ip6.addr[3] = _17;
  # DEBUG BEGIN_STMT
  _18 = MEM[(const struct ip_addr_t *)netif_8(D) + 4B].u_addr.ip6.zone;
  old_addr_7(D)->u_addr.ip6.zone = _18;
  # DEBUG BEGIN_STMT
  goto <bb 10>; [100.00%]

  <bb 9> [local count: 57875]:
  # DEBUG BEGIN_STMT
  old_addr_7(D)->u_addr.ip4.addr = _12;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  old_addr_7(D)->u_addr.ip6.addr[3] = 0;
  old_addr_7(D)->u_addr.ip6.addr[2] = 0;
  old_addr_7(D)->u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  old_addr_7(D)->u_addr.ip6.zone = 0;

  <bb 10> [local count: 87689]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_do_ip_addr_changed (old_addr_7(D), &new_addr);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  iftmp.4_19 = ipaddr_5(D)->addr;
  netif_8(D)->ip_addr.u_addr.ip4.addr = iftmp.4_19;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_8(D)->ip_addr.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif_8(D), 1);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  new_addr ={v} {CLOBBER};

  <bb 11> [local count: 175378]:
  # _20 = PHI <0(6), 1(10)>
  _41 = _20;
  # DEBUG netif => NULL
  # DEBUG ipaddr => NULL
  # DEBUG old_addr => NULL
  _2 = _41;
  return _2;

}



;; Function netif_null_output_ip4 (netif_null_output_ip4, funcdef_no=41, decl_uid=7832, cgraph_uid=29, symbol_order=32)


Symbols to be put in SSA form
{ D.8539 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 6
Number of blocks to update: 5 ( 83%)


Merging blocks 2 and 4
Merging blocks 2 and 5
Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
netif_null_output_ip4 (struct netif * netif, struct pbuf * p, const struct ip4_addr_t * ipaddr)
{
  err_t D.8539;
  err_t retval.59;

  <bb 2> [local count: 1073741824]:
  # DEBUG D#6 => netif_1(D)
  # DEBUG D#7 => p_2(D)
  # DEBUG D#8 => ipaddr_3(D)
  # DEBUG D#11 => D#6
  # DEBUG netif => D#11
  # DEBUG D#10 => D#7
  # DEBUG p => D#10
  # DEBUG D#9 => D#8
  # DEBUG ipaddr => D#9
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _6 = -12;
  # DEBUG netif => NULL
  # DEBUG p => NULL
  # DEBUG ipaddr => NULL
  retval.59_4 = _6;
  return retval.59_4;

}



;; Function netif_init (netif_init, funcdef_no=1, decl_uid=6791, cgraph_uid=2, symbol_order=5)

netif_init ()
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_input (netif_input, funcdef_no=2, decl_uid=6835, cgraph_uid=3, symbol_order=6)

netif_input (struct pbuf * p, struct netif * inp)
{
  unsigned char _1;
  err_t _2;
  err_t _10;
  err_t _12;
  unsigned char _15;

  <bb 2> [local count: 357913]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (p_6(D) == 0B)
    goto <bb 10>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 10> [local count: 107374]:

  <bb 3> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 12> [local count: 1073741824]:
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 250539]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (inp_8(D) == 0B)
    goto <bb 11>; [30.00%]
  else
    goto <bb 6>; [70.00%]

  <bb 11> [local count: 75162]:

  <bb 5> [local count: 751619279]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 13> [local count: 751619279]:
  goto <bb 5>; [100.00%]

  <bb 6> [local count: 175378]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = inp_8(D)->flags;
  _15 = _1 & 24;
  if (_15 != 0)
    goto <bb 7>; [50.00%]
  else
    goto <bb 8>; [50.00%]

  <bb 7> [local count: 87689]:
  # DEBUG BEGIN_STMT
  _12 = ethernet_input (p_6(D), inp_8(D));
  goto <bb 9>; [100.00%]

  <bb 8> [local count: 87689]:
  # DEBUG BEGIN_STMT
  _10 = ip_input (p_6(D), inp_8(D));

  <bb 9> [local count: 175378]:
  # _2 = PHI <_12(7), _10(8)>
  return _2;

}



;; Function netif_set_ipaddr (netif_set_ipaddr, funcdef_no=7, decl_uid=6818, cgraph_uid=8, symbol_order=11)

netif_set_ipaddr (struct netif * netif, const struct ip4_addr_t * ipaddr)
{
  struct ip_addr_t old_addr;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_3(D) == 0B)
    goto <bb 3>; [18.09%]
  else
    goto <bb 4>; [81.91%]

  <bb 3> [local count: 194239896]:
  # DEBUG BEGIN_STMT
  old_addr ={v} {CLOBBER};
  goto <bb 7>; [100.00%]

  <bb 4> [local count: 879501929]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr_4(D) == 0B)
    goto <bb 5>; [30.00%]
  else
    goto <bb 6>; [70.00%]

  <bb 5> [local count: 263850578]:
  # DEBUG BEGIN_STMT
  # DEBUG ipaddr => &ip_addr_any.u_addr.ip4

  <bb 6> [local count: 879501928]:
  # ipaddr_1 = PHI <ipaddr_4(D)(4), &ip_addr_any.u_addr.ip4(5)>
  # DEBUG ipaddr => ipaddr_1
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_do_set_ipaddr (netif_3(D), ipaddr_1, &old_addr);
  # DEBUG BEGIN_STMT
  old_addr ={v} {CLOBBER};

  <bb 7> [local count: 1073741824]:
  return;

}



;; Function netif_set_netmask (netif_set_netmask, funcdef_no=9, decl_uid=6821, cgraph_uid=10, symbol_order=13)

netif_set_netmask (struct netif * netif, const struct ip4_addr_t * netmask)
{
  long unsigned int _6;
  long unsigned int _7;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG old_nm => 0B
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_3(D) == 0B)
    goto <bb 7>; [18.09%]
  else
    goto <bb 3>; [81.91%]

  <bb 3> [local count: 879501929]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netmask_4(D) == 0B)
    goto <bb 4>; [30.00%]
  else
    goto <bb 5>; [70.00%]

  <bb 4> [local count: 263850578]:
  # DEBUG BEGIN_STMT
  # DEBUG netmask => &ip_addr_any.u_addr.ip4

  <bb 5> [local count: 879501928]:
  # netmask_1 = PHI <netmask_4(D)(3), &ip_addr_any.u_addr.ip4(4)>
  # DEBUG netmask => netmask_1
  # DEBUG BEGIN_STMT
  _6 = MEM[(long unsigned int *)netmask_1];
  # DEBUG D#1 => netmask_1
  # DEBUG D#2 => 0B
  # DEBUG netif => netif_3(D)
  # DEBUG INLINE_ENTRY netif_do_set_netmask
  # DEBUG netmask => D#1
  # DEBUG old_nm => D#2
  # DEBUG BEGIN_STMT
  _7 = MEM[(const struct ip4_addr_t *)netif_3(D) + 28B].addr;
  if (_6 != _7)
    goto <bb 6>; [50.00%]
  else
    goto <bb 7>; [50.00%]

  <bb 6> [local count: 439750964]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_3(D)->netmask.u_addr.ip4.addr = _6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_3(D)->netmask.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT

  <bb 7> [local count: 1073741824]:
  # DEBUG netif => NULL
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_set_gw (netif_set_gw, funcdef_no=11, decl_uid=6824, cgraph_uid=12, symbol_order=15)

netif_set_gw (struct netif * netif, const struct ip4_addr_t * gw)
{
  long unsigned int _6;
  long unsigned int _7;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG old_gw => 0B
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_3(D) == 0B)
    goto <bb 7>; [18.09%]
  else
    goto <bb 3>; [81.91%]

  <bb 3> [local count: 879501929]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (gw_4(D) == 0B)
    goto <bb 4>; [30.00%]
  else
    goto <bb 5>; [70.00%]

  <bb 4> [local count: 263850578]:
  # DEBUG BEGIN_STMT
  # DEBUG gw => &ip_addr_any.u_addr.ip4

  <bb 5> [local count: 879501928]:
  # gw_1 = PHI <gw_4(D)(3), &ip_addr_any.u_addr.ip4(4)>
  # DEBUG gw => gw_1
  # DEBUG BEGIN_STMT
  _6 = MEM[(long unsigned int *)gw_1];
  # DEBUG D#3 => gw_1
  # DEBUG D#4 => 0B
  # DEBUG netif => netif_3(D)
  # DEBUG INLINE_ENTRY netif_do_set_gw
  # DEBUG gw => D#3
  # DEBUG old_gw => D#4
  # DEBUG BEGIN_STMT
  _7 = MEM[(const struct ip4_addr_t *)netif_3(D) + 52B].addr;
  if (_6 != _7)
    goto <bb 6>; [50.00%]
  else
    goto <bb 7>; [50.00%]

  <bb 6> [local count: 439750964]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_3(D)->gw.u_addr.ip4.addr = _6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_3(D)->gw.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT

  <bb 7> [local count: 1073741824]:
  # DEBUG netif => NULL
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_set_addr (netif_set_addr, funcdef_no=12, decl_uid=6809, cgraph_uid=13, symbol_order=16)

netif_set_addr (struct netif * netif, const struct ip4_addr_t * ipaddr, const struct ip4_addr_t * netmask, const struct ip4_addr_t * gw)
{
  struct ip_addr_t old_addr;
  long unsigned int _1;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  int iftmp.7_18;
  long unsigned int _19;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG old_nm => 0B
  # DEBUG BEGIN_STMT
  # DEBUG old_gw => 0B
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr_7(D) == 0B)
    goto <bb 3>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 3> [local count: 322122547]:
  # DEBUG BEGIN_STMT
  # DEBUG ipaddr => &ip_addr_any.u_addr.ip4

  <bb 4> [local count: 1073741824]:
  # ipaddr_2 = PHI <ipaddr_7(D)(2), &ip_addr_any.u_addr.ip4(3)>
  # DEBUG ipaddr => ipaddr_2
  # DEBUG BEGIN_STMT
  if (netmask_8(D) == 0B)
    goto <bb 5>; [30.00%]
  else
    goto <bb 6>; [70.00%]

  <bb 5> [local count: 322122547]:
  # DEBUG BEGIN_STMT
  # DEBUG netmask => &ip_addr_any.u_addr.ip4

  <bb 6> [local count: 1073741824]:
  # netmask_3 = PHI <netmask_8(D)(4), &ip_addr_any.u_addr.ip4(5)>
  # DEBUG netmask => netmask_3
  # DEBUG BEGIN_STMT
  if (gw_9(D) == 0B)
    goto <bb 7>; [30.00%]
  else
    goto <bb 8>; [70.00%]

  <bb 7> [local count: 322122547]:
  # DEBUG BEGIN_STMT
  # DEBUG gw => &ip_addr_any.u_addr.ip4

  <bb 8> [local count: 1073741824]:
  # gw_4 = PHI <gw_9(D)(6), &ip_addr_any.u_addr.ip4(7)>
  # DEBUG gw => gw_4
  # DEBUG BEGIN_STMT
  if (ipaddr_2 == 0B)
    goto <bb 10>; [17.43%]
  else
    goto <bb 9>; [82.57%]

  <bb 9> [local count: 886588625]:
  _1 = ipaddr_2->addr;
  if (_1 == 0)
    goto <bb 10>; [50.00%]
  else
    goto <bb 11>; [50.00%]

  <bb 10> [local count: 630447513]:
  # DEBUG remove => NULL
  # DEBUG BEGIN_STMT
  netif_do_set_ipaddr (netif_11(D), ipaddr_2, &old_addr);

  <bb 11> [local count: 1073741824]:
  # iftmp.7_18 = PHI <0(9), 1(10)>
  # DEBUG remove => NULL
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _15 = MEM[(long unsigned int *)netmask_3];
  # DEBUG D#1 => netmask_3
  # DEBUG D#2 => 0B
  # DEBUG netif => netif_11(D)
  # DEBUG INLINE_ENTRY netif_do_set_netmask
  # DEBUG netmask => D#1
  # DEBUG old_nm => D#2
  # DEBUG BEGIN_STMT
  _19 = MEM[(const struct ip4_addr_t *)netif_11(D) + 28B].addr;
  if (_15 != _19)
    goto <bb 12>; [50.00%]
  else
    goto <bb 13>; [50.00%]

  <bb 12> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_11(D)->netmask.u_addr.ip4.addr = _15;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_11(D)->netmask.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT

  <bb 13> [local count: 1073741824]:
  # DEBUG netif => NULL
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _16 = MEM[(long unsigned int *)gw_4];
  # DEBUG D#3 => gw_4
  # DEBUG D#4 => 0B
  # DEBUG netif => netif_11(D)
  # DEBUG INLINE_ENTRY netif_do_set_gw
  # DEBUG gw => D#3
  # DEBUG old_gw => D#4
  # DEBUG BEGIN_STMT
  _17 = MEM[(const struct ip4_addr_t *)netif_11(D) + 52B].addr;
  if (_16 != _17)
    goto <bb 14>; [50.00%]
  else
    goto <bb 15>; [50.00%]

  <bb 14> [local count: 536870913]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_11(D)->gw.u_addr.ip4.addr = _16;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_11(D)->gw.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT

  <bb 15> [local count: 1073741824]:
  # DEBUG netif => NULL
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (iftmp.7_18 == 0)
    goto <bb 16>; [33.00%]
  else
    goto <bb 17>; [67.00%]

  <bb 16> [local count: 354334802]:
  # DEBUG BEGIN_STMT
  netif_do_set_ipaddr (netif_11(D), ipaddr_2, &old_addr);

  <bb 17> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  old_addr ={v} {CLOBBER};
  return;

}



;; Function netif_add (netif_add, funcdef_no=4, decl_uid=6804, cgraph_uid=5, symbol_order=8)

netif_add (struct netif * netif, const struct ip4_addr_t * ipaddr, const struct ip4_addr_t * netmask, const struct ip4_addr_t * gw, void * state, err_t (*netif_init_fn) (struct netif *) init, err_t (*netif_input_fn) (struct pbuf *, struct netif *) input)
{
  int num_netifs;
  struct netif * netif2;
  s8_t i;
  int _1;
  unsigned char i.1_3;
  unsigned char _4;
  void *[3] * _5;
  unsigned char netif_num.2_6;
  signed char _7;
  short unsigned int _8;
  unsigned char _9;
  unsigned char _10;
  unsigned char _11;
  unsigned char _12;
  unsigned char _13;
  unsigned char _14;
  unsigned char _16;
  unsigned char _18;
  struct netif * _25;
  unsigned char _37;

  <bb 2> [local count: 220326]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_34(D) == 0B)
    goto <bb 32>; [8.27%]
  else
    goto <bb 3>; [91.73%]

  <bb 3> [local count: 202105]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (init_35(D) == 0B)
    goto <bb 32>; [8.27%]
  else
    goto <bb 4>; [91.73%]

  <bb 4> [local count: 185391]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr_36(D) == 0B)
    goto <bb 5>; [30.00%]
  else
    goto <bb 6>; [70.00%]

  <bb 5> [local count: 55617]:
  # DEBUG BEGIN_STMT
  # DEBUG ipaddr => &ip_addr_any.u_addr.ip4

  <bb 6> [local count: 185391]:
  # ipaddr_19 = PHI <ipaddr_36(D)(4), &ip_addr_any.u_addr.ip4(5)>
  # DEBUG ipaddr => ipaddr_19
  # DEBUG BEGIN_STMT
  if (netmask_38(D) == 0B)
    goto <bb 7>; [30.00%]
  else
    goto <bb 8>; [70.00%]

  <bb 7> [local count: 55617]:
  # DEBUG BEGIN_STMT
  # DEBUG netmask => &ip_addr_any.u_addr.ip4

  <bb 8> [local count: 185391]:
  # netmask_20 = PHI <netmask_38(D)(6), &ip_addr_any.u_addr.ip4(7)>
  # DEBUG netmask => netmask_20
  # DEBUG BEGIN_STMT
  if (gw_39(D) == 0B)
    goto <bb 9>; [30.00%]
  else
    goto <bb 10>; [70.00%]

  <bb 9> [local count: 55617]:
  # DEBUG BEGIN_STMT
  # DEBUG gw => &ip_addr_any.u_addr.ip4

  <bb 10> [local count: 185391]:
  # gw_21 = PHI <gw_39(D)(8), &ip_addr_any.u_addr.ip4(9)>
  # DEBUG gw => gw_21
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->ip_addr.u_addr.ip6.addr[0] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip_addr.u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip_addr.u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip_addr.u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip_addr.u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->ip_addr.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->netmask.u_addr.ip6.addr[0] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->netmask.u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->netmask.u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->netmask.u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->netmask.u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->netmask.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->gw.u_addr.ip6.addr[0] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->gw.u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->gw.u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->gw.u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->gw.u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->gw.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->output = netif_null_output_ip4;
  # DEBUG BEGIN_STMT
  # DEBUG i => 0
  goto <bb 12>; [100.00%]

  <bb 11> [local count: 556173]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) i_22;
  netif_34(D)->ip6_addr[_1].u_addr.ip6.addr[0] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_addr[_1].u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_addr[_1].u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_addr[_1].u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_addr[_1].u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_addr[_1].type = 6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_addr_state[_1] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_addr_valid_life[_1] = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_addr_pref_life[_1] = 0;
  # DEBUG BEGIN_STMT
  i.1_3 = (unsigned char) i_22;
  _4 = i.1_3 + 1;
  i_97 = (s8_t) _4;
  # DEBUG i => i_97

  <bb 12> [local count: 741564]:
  # i_22 = PHI <0(10), i_97(11)>
  # DEBUG i => i_22
  # DEBUG BEGIN_STMT
  if (i_22 != 3)
    goto <bb 11>; [75.00%]
  else
    goto <bb 13>; [25.00%]

  <bb 13> [local count: 185391]:
  # DEBUG BEGIN_STMT
  netif_34(D)->output_ip6 = netif_null_output_ip6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_34(D)->mtu = 0;
  # DEBUG BEGIN_STMT
  netif_34(D)->flags = 0;
  # DEBUG BEGIN_STMT
  _5 = &netif_34(D)->client_data;
  memset (_5, 0, 12);
  # DEBUG BEGIN_STMT
  netif_34(D)->ip6_autoconfig_enabled = 0;
  # DEBUG BEGIN_STMT
  nd6_restart_netif (netif_34(D));
  # DEBUG BEGIN_STMT
  netif_34(D)->igmp_mac_filter = 0B;
  # DEBUG BEGIN_STMT
  netif_34(D)->mld_mac_filter = 0B;
  # DEBUG BEGIN_STMT
  netif_34(D)->state = state_68(D);
  # DEBUG BEGIN_STMT
  netif_num.2_6 = netif_num;
  netif_34(D)->num = netif_num.2_6;
  # DEBUG BEGIN_STMT
  netif_34(D)->input = input_71(D);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_set_addr (netif_34(D), ipaddr_19, netmask_20, gw_21);
  # DEBUG BEGIN_STMT
  _7 = init_35(D) (netif_34(D));
  if (_7 != 0)
    goto <bb 32>; [17.38%]
  else
    goto <bb 14>; [82.62%]

  <bb 14> [local count: 153170]:
  # DEBUG BEGIN_STMT
  _8 = netif_34(D)->mtu;
  netif_34(D)->mtu6 = _8;

  <bb 15> [local count: 359133]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _9 = netif_34(D)->num;
  if (_9 == 255)
    goto <bb 16>; [34.00%]
  else
    goto <bb 17>; [66.00%]

  <bb 16> [local count: 122105]:
  # DEBUG BEGIN_STMT
  netif_34(D)->num = 0;

  <bb 17> [local count: 359133]:
  # DEBUG BEGIN_STMT
  # DEBUG num_netifs => 0
  # DEBUG BEGIN_STMT
  netif2_77 = netif_list;
  # DEBUG netif2 => netif2_77
  goto <bb 25>; [100.00%]

  <bb 18> [local count: 3904509]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif2_23 == netif_34(D))
    goto <bb 33>; [2.75%]
  else
    goto <bb 20>; [97.25%]

  <bb 33> [local count: 107374]:

  <bb 19> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 35> [local count: 1073741824]:
  goto <bb 19>; [100.00%]

  <bb 20> [local count: 3797135]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  num_netifs_78 = num_netifs_24 + 1;
  # DEBUG num_netifs => num_netifs_78
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (num_netifs_78 == 256)
    goto <bb 34>; [1.00%]
  else
    goto <bb 22>; [99.00%]

  <bb 34> [local count: 37971]:

  <bb 21> [local count: 379714154]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 36> [local count: 379714154]:
  goto <bb 21>; [100.00%]

  <bb 22> [local count: 3759164]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _10 = netif2_23->num;
  _11 = netif_34(D)->num;
  if (_10 == _11)
    goto <bb 23>; [2.75%]
  else
    goto <bb 24>; [97.25%]

  <bb 23> [local count: 103377]:
  # _12 = PHI <_11(22)>
  # netif2_15 = PHI <netif2_23(22)>
  # DEBUG BEGIN_STMT
  _13 = _12 + 1;
  netif_34(D)->num = _13;
  # DEBUG BEGIN_STMT
  goto <bb 26>; [100.00%]

  <bb 24> [local count: 3655787]:
  # DEBUG BEGIN_STMT
  netif2_79 = netif2_23->next;
  # DEBUG netif2 => netif2_79

  <bb 25> [local count: 4014919]:
  # netif2_23 = PHI <netif2_77(17), netif2_79(24)>
  # num_netifs_24 = PHI <0(17), num_netifs_78(24)>
  # DEBUG num_netifs => num_netifs_24
  # DEBUG netif2 => netif2_23
  # DEBUG BEGIN_STMT
  if (netif2_23 != 0B)
    goto <bb 18>; [97.25%]
  else
    goto <bb 26>; [2.75%]

  <bb 26> [local count: 213787]:
  # netif2_17 = PHI <netif2_15(23), netif2_23(25)>
  # DEBUG BEGIN_STMT
  if (netif2_17 != 0B)
    goto <bb 37>; [96.34%]
  else
    goto <bb 27>; [3.66%]

  <bb 37> [local count: 205962]:
  goto <bb 15>; [100.00%]

  <bb 27> [local count: 7825]:
  # netif2_2 = PHI <netif2_77(26)>
  # DEBUG BEGIN_STMT
  _14 = netif_34(D)->num;
  if (_14 == 254)
    goto <bb 28>; [34.00%]
  else
    goto <bb 29>; [66.00%]

  <bb 28> [local count: 2660]:
  # DEBUG BEGIN_STMT
  netif_num = 0;
  goto <bb 30>; [100.00%]

  <bb 29> [local count: 5164]:
  # DEBUG BEGIN_STMT
  _16 = _14 + 1;
  netif_num = _16;

  <bb 30> [local count: 7825]:
  # DEBUG BEGIN_STMT
  netif_34(D)->next = netif2_2;
  # DEBUG BEGIN_STMT
  netif_list = netif_34(D);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _18 = netif_34(D)->flags;
  _37 = _18 & 32;
  if (_37 != 0)
    goto <bb 31>; [33.00%]
  else
    goto <bb 32>; [67.00%]

  <bb 31> [local count: 2582]:
  # DEBUG BEGIN_STMT
  igmp_start (netif_34(D));

  <bb 32> [local count: 74981]:
  # _25 = PHI <0B(2), 0B(3), 0B(13), netif_34(D)(31), netif_34(D)(30)>
  return _25;

}



;; Function netif_add_noaddr (netif_add_noaddr, funcdef_no=3, decl_uid=6796, cgraph_uid=4, symbol_order=7)

netif_add_noaddr (struct netif * netif, void * state, err_t (*netif_init_fn) (struct netif *) init, err_t (*netif_input_fn) (struct pbuf *, struct netif *) input)
{
  struct netif * _7;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  _7 = netif_add (netif_2(D), 0B, 0B, 0B, state_3(D), init_4(D), input_5(D));
  return _7;

}



;; Function netif_set_default (netif_set_default, funcdef_no=14, decl_uid=6815, cgraph_uid=15, symbol_order=18)

netif_set_default (struct netif * netif)
{
  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_default = netif_2(D);
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_set_up (netif_set_up, funcdef_no=15, decl_uid=6826, cgraph_uid=16, symbol_order=19)

netif_set_up (struct netif * netif)
{
  unsigned char _1;
  unsigned char _2;
  long unsigned int _3;
  long unsigned int _4;
  unsigned char _13;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_6(D) == 0B)
    goto <bb 5>; [18.09%]
  else
    goto <bb 3>; [81.91%]

  <bb 3> [local count: 879501929]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif_6(D)->flags;
  _13 = _1 & 1;
  if (_13 == 0)
    goto <bb 4>; [33.00%]
  else
    goto <bb 5>; [67.00%]

  <bb 4> [local count: 290235636]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = _1 | 1;
  netif_6(D)->flags = _2;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _3 = sys_now ();
  _4 = _3 / 10;
  netif_6(D)->ts = _4;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif_6(D), 3);
  # DEBUG BEGIN_STMT
  nd6_restart_netif (netif_6(D));

  <bb 5> [local count: 1073741824]:
  return;

}



;; Function netif_set_down (netif_set_down, funcdef_no=17, decl_uid=6828, cgraph_uid=18, symbol_order=21)

netif_set_down (struct netif * netif)
{
  unsigned char _1;
  unsigned char _2;
  long unsigned int _3;
  long unsigned int _4;
  unsigned char _5;
  unsigned char _15;
  unsigned char _16;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_8(D) == 0B)
    goto <bb 7>; [18.09%]
  else
    goto <bb 3>; [81.91%]

  <bb 3> [local count: 879501929]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif_8(D)->flags;
  _15 = _1 & 1;
  if (_15 != 0)
    goto <bb 4>; [33.00%]
  else
    goto <bb 7>; [67.00%]

  <bb 4> [local count: 290235636]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = _1 & 254;
  netif_8(D)->flags = _2;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _3 = sys_now ();
  _4 = _3 / 10;
  netif_8(D)->ts = _4;
  # DEBUG BEGIN_STMT
  _5 = netif_8(D)->flags;
  _16 = _5 & 8;
  if (_16 != 0)
    goto <bb 5>; [33.00%]
  else
    goto <bb 6>; [67.00%]

  <bb 5> [local count: 95777760]:
  # DEBUG BEGIN_STMT
  etharp_cleanup_netif (netif_8(D));

  <bb 6> [local count: 290235636]:
  # DEBUG BEGIN_STMT
  nd6_cleanup_netif (netif_8(D));

  <bb 7> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_remove (netif_remove, funcdef_no=13, decl_uid=6811, cgraph_uid=14, symbol_order=17)

netif_remove (struct netif * netif)
{
  struct netif * tmp_netif;
  int i;
  long unsigned int _2;
  struct ip_addr_t * _3;
  unsigned char _4;
  unsigned char _5;
  struct ip_addr_t * _6;
  unsigned char _7;
  _Bool _8;
  struct netif * netif_default.8_9;
  struct netif * netif_list.9_10;
  struct netif * _11;
  struct netif * _12;
  struct netif * _13;
  unsigned char _28;
  unsigned char _31;

  <bb 2> [local count: 200330558]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_24(D) == 0B)
    goto <bb 22>; [18.09%]
  else
    goto <bb 3>; [81.91%]

  <bb 3> [local count: 164090760]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = MEM[(const struct ip4_addr_t *)netif_24(D) + 4B].addr;
  if (_2 != 0)
    goto <bb 4>; [33.00%]
  else
    goto <bb 5>; [67.00%]

  <bb 4> [local count: 54149951]:
  # DEBUG BEGIN_STMT
  _3 = &netif_24(D)->ip_addr;
  netif_do_ip_addr_changed (_3, 0B);

  <bb 5> [local count: 164090760]:
  # DEBUG BEGIN_STMT
  _4 = netif_24(D)->flags;
  _28 = _4 & 32;
  if (_28 != 0)
    goto <bb 6>; [33.00%]
  else
    goto <bb 7>; [67.00%]

  <bb 6> [local count: 54149951]:
  # DEBUG BEGIN_STMT
  igmp_stop (netif_24(D));

  <bb 7> [local count: 164090760]:
  # i_17 = PHI <0(6), 0(5)>
  goto <bb 11>; [100.00%]

  <bb 8> [local count: 492272281]:
  # DEBUG BEGIN_STMT
  _5 = netif_24(D)->ip6_addr_state[i_14];
  _31 = _5 & 16;
  if (_31 != 0)
    goto <bb 9>; [33.00%]
  else
    goto <bb 10>; [67.00%]

  <bb 9> [local count: 162449853]:
  # DEBUG BEGIN_STMT
  _6 = &netif_24(D)->ip6_addr[i_14];
  netif_do_ip_addr_changed (_6, 0B);

  <bb 10> [local count: 492272281]:
  # DEBUG BEGIN_STMT
  i_36 = i_14 + 1;
  # DEBUG i => i_36

  <bb 11> [local count: 656363042]:
  # i_14 = PHI <i_17(7), i_36(10)>
  # DEBUG i => i_14
  # DEBUG BEGIN_STMT
  if (i_14 != 3)
    goto <bb 8>; [75.00%]
  else
    goto <bb 12>; [25.00%]

  <bb 12> [local count: 164090760]:
  # DEBUG BEGIN_STMT
  mld6_stop (netif_24(D));
  # DEBUG BEGIN_STMT
  _7 = netif_24(D)->flags;
  _8 = (_Bool) _7;
  if (_8 != 0)
    goto <bb 13>; [33.00%]
  else
    goto <bb 14>; [67.00%]

  <bb 13> [local count: 54149951]:
  # DEBUG BEGIN_STMT
  netif_set_down (netif_24(D));

  <bb 14> [local count: 164090760]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_default.8_9 = netif_default;
  if (netif_default.8_9 == netif_24(D))
    goto <bb 15>; [30.00%]
  else
    goto <bb 16>; [70.00%]

  <bb 15> [local count: 49227228]:
  # DEBUG BEGIN_STMT
  # DEBUG netif => 0B
  # DEBUG INLINE_ENTRY netif_set_default
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_default = 0B;
  # DEBUG BEGIN_STMT

  <bb 16> [local count: 164090760]:
  # DEBUG netif => NULL
  # DEBUG BEGIN_STMT
  netif_list.9_10 = netif_list;
  if (netif_list.9_10 == netif_24(D))
    goto <bb 17>; [30.00%]
  else
    goto <bb 23>; [70.00%]

  <bb 17> [local count: 49227228]:
  # DEBUG BEGIN_STMT
  _11 = netif_24(D)->next;
  netif_list = _11;
  goto <bb 22>; [100.00%]

  <bb 18> [local count: 1014686025]:
  # DEBUG BEGIN_STMT
  _12 = tmp_netif_15->next;
  if (_12 == netif_24(D))
    goto <bb 19>; [5.50%]
  else
    goto <bb 24>; [94.50%]

  <bb 24> [local count: 958878294]:
  goto <bb 20>; [100.00%]

  <bb 19> [local count: 55807731]:
  # tmp_netif_32 = PHI <tmp_netif_15(18)>
  # DEBUG BEGIN_STMT
  _13 = netif_24(D)->next;
  tmp_netif_32->next = _13;
  # DEBUG BEGIN_STMT
  goto <bb 21>; [100.00%]

  <bb 23> [local count: 114863532]:

  <bb 20> [local count: 1073741824]:
  # tmp_netif_15 = PHI <netif_list.9_10(23), _12(24)>
  # DEBUG tmp_netif => tmp_netif_15
  # DEBUG BEGIN_STMT
  if (tmp_netif_15 != 0B)
    goto <bb 18>; [94.50%]
  else
    goto <bb 21>; [5.50%]

  <bb 21> [local count: 114863532]:
  # DEBUG BEGIN_STMT

  <bb 22> [local count: 200330558]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_set_link_up (netif_set_link_up, funcdef_no=18, decl_uid=6830, cgraph_uid=19, symbol_order=22)

netif_set_link_up (struct netif * netif)
{
  unsigned char _1;
  unsigned char _2;
  unsigned char _9;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_4(D) == 0B)
    goto <bb 5>; [18.09%]
  else
    goto <bb 3>; [81.91%]

  <bb 3> [local count: 879501929]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif_4(D)->flags;
  _9 = _1 & 4;
  if (_9 == 0)
    goto <bb 4>; [33.00%]
  else
    goto <bb 5>; [67.00%]

  <bb 4> [local count: 290235636]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = _1 | 4;
  netif_4(D)->flags = _2;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif_4(D), 3);
  # DEBUG BEGIN_STMT
  nd6_restart_netif (netif_4(D));

  <bb 5> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_set_link_down (netif_set_link_down, funcdef_no=19, decl_uid=6832, cgraph_uid=20, symbol_order=23)

netif_set_link_down (struct netif * netif)
{
  unsigned char _1;
  unsigned char _2;
  short unsigned int _3;
  unsigned char _9;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_5(D) == 0B)
    goto <bb 5>; [18.09%]
  else
    goto <bb 3>; [81.91%]

  <bb 3> [local count: 879501929]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif_5(D)->flags;
  _9 = _1 & 4;
  if (_9 != 0)
    goto <bb 4>; [50.00%]
  else
    goto <bb 5>; [50.00%]

  <bb 4> [local count: 439750964]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = _1 & 251;
  netif_5(D)->flags = _2;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _3 = netif_5(D)->mtu;
  netif_5(D)->mtu6 = _3;

  <bb 5> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_alloc_client_data_id (netif_alloc_client_data_id, funcdef_no=20, decl_uid=6756, cgraph_uid=21, symbol_order=24)

netif_alloc_client_data_id ()
{
  u8_t result;
  unsigned char _1;

  <bb 2> [local count: 214748]:
  # DEBUG BEGIN_STMT
  result_4 = netif_client_id;
  # DEBUG result => result_4
  # DEBUG BEGIN_STMT
  _1 = result_4 + 1;
  netif_client_id = _1;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (result_4 != 0)
    goto <bb 5>; [50.00%]
  else
    goto <bb 4>; [50.00%]

  <bb 5> [local count: 107374]:

  <bb 3> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 6> [local count: 1073741824]:
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 107374]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  return 2;

}



;; Function netif_ip6_addr_set_parts (netif_ip6_addr_set_parts, funcdef_no=22, decl_uid=6846, cgraph_uid=23, symbol_order=26)


Symbols to be put in SSA form
{ D.8387 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 27
Number of blocks to update: 26 ( 96%)


Merging blocks 3 and 9
Merging blocks 5 and 10
Removing basic block 6
Removing basic block 7
Removing basic block 8
Removing basic block 12
Merging blocks 26 and 11
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
;;
;; Loop 2
;;  header 3, latch 3
;;  depth 1, outer 0
;;  nodes: 3
;;
;; Loop 1
;;  header 5, latch 5
;;  depth 1, outer 0
;;  nodes: 5
;; 2 succs { 3 4 }
;; 3 succs { 3 }
;; 4 succs { 5 6 }
;; 5 succs { 5 }
;; 6 succs { 10 7 }
;; 7 succs { 10 8 }
;; 8 succs { 10 9 }
;; 9 succs { 10 19 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 16 }
;; 15 succs { 17 }
;; 16 succs { 17 }
;; 17 succs { 18 19 }
;; 18 succs { 19 }
;; 19 succs { 1 }
netif_ip6_addr_set_parts (struct netif * netif, s8_t addr_idx, u32_t i0, u32_t i1, u32_t i2, u32_t i3)
{
  struct ip_addr_t new_ipaddr;
  int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  unsigned char _19;
  unsigned char iftmp.12_20;
  unsigned char iftmp.12_21;
  unsigned char _22;
  unsigned char _23;
  struct ip_addr_t * _24;
  unsigned char _25;
  long unsigned int _26;
  long unsigned int _27;
  long unsigned int _28;
  long unsigned int _29;
  unsigned char _30;
  long unsigned int _31;
  unsigned char _32;
  unsigned char _33;

  <bb 2> [local count: 306783]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_4(D) == 0B)
    goto <bb 3>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 3> [local count: 920350134]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 214748]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (addr_idx_6(D) > 2)
    goto <bb 5>; [50.00%]
  else
    goto <bb 6>; [50.00%]

  <bb 5> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [100.00%]

  <bb 6> [local count: 107374]:
  # DEBUG netif => netif_4(D)
  # DEBUG addr_idx => addr_idx_6(D)
  # DEBUG i0 => i0_7(D)
  # DEBUG i1 => i1_8(D)
  # DEBUG i2 => i2_9(D)
  # DEBUG i3 => i3_10(D)
  # DEBUG INLINE_ENTRY netif_ip6_addr_set_parts
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _13 = (int) addr_idx_6(D);
  _14 = MEM[(const struct ip6_addr_t *)netif_4(D)].ip6_addr[_13].u_addr.ip6.addr[0];
  # DEBUG old_addr$u_addr$ip6$addr$0 => _14
  # DEBUG BEGIN_STMT
  _15 = MEM[(const struct ip6_addr_t *)netif_4(D)].ip6_addr[_13].u_addr.ip6.addr[1];
  # DEBUG old_addr$u_addr$ip6$addr$1 => _15
  # DEBUG BEGIN_STMT
  _16 = MEM[(const struct ip6_addr_t *)netif_4(D)].ip6_addr[_13].u_addr.ip6.addr[2];
  # DEBUG old_addr$u_addr$ip6$addr$2 => _16
  # DEBUG BEGIN_STMT
  _17 = MEM[(const struct ip6_addr_t *)netif_4(D)].ip6_addr[_13].u_addr.ip6.addr[3];
  # DEBUG old_addr$u_addr$ip6$addr$3 => _17
  # DEBUG BEGIN_STMT
  # DEBUG D#5 => MEM[(const struct ip6_addr_t *)netif_4(D)].ip6_addr[_13].u_addr.ip6.zone
  # DEBUG old_addr$u_addr$ip6$zone => D#5
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG old_addr$type => 6
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (i0_7(D) != _14)
    goto <bb 10>; [66.00%]
  else
    goto <bb 7>; [34.00%]

  <bb 7> [local count: 36507]:
  if (i1_8(D) != _15)
    goto <bb 10>; [66.00%]
  else
    goto <bb 8>; [34.00%]

  <bb 8> [local count: 12412]:
  if (i2_9(D) != _16)
    goto <bb 10>; [66.00%]
  else
    goto <bb 9>; [34.00%]

  <bb 9> [local count: 4220]:
  if (i3_10(D) != _17)
    goto <bb 10>; [66.00%]
  else
    goto <bb 19>; [34.00%]

  <bb 10> [local count: 105939]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.addr[0] = i0_7(D);
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.addr[1] = i1_8(D);
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.addr[2] = i2_9(D);
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.addr[3] = i3_10(D);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_ipaddr.type = 6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _18 = i0_7(D) & 49407;
  if (_18 == 33022)
    goto <bb 11>; [34.00%]
  else
    goto <bb 12>; [66.00%]

  <bb 11> [local count: 36019]:
  _19 = netif_4(D)->num;
  iftmp.12_20 = _19 + 1;

  <bb 12> [local count: 105939]:
  # iftmp.12_21 = PHI <0(10), iftmp.12_20(11)>
  new_ipaddr.u_addr.ip6.zone = iftmp.12_21;
  # DEBUG BEGIN_STMT
  _22 = netif_4(D)->ip6_addr_state[_13];
  _23 = _22 & 16;
  if (_23 != 0)
    goto <bb 13>; [33.00%]
  else
    goto <bb 14>; [67.00%]

  <bb 13> [local count: 34960]:
  # DEBUG BEGIN_STMT
  _24 = &netif_4(D)->ip6_addr[_13];
  netif_do_ip_addr_changed (_24, &new_ipaddr);

  <bb 14> [local count: 105939]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _25 = new_ipaddr.type;
  netif_4(D)->ip6_addr[_13].type = _25;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (_25 == 6)
    goto <bb 15>; [34.00%]
  else
    goto <bb 16>; [66.00%]

  <bb 15> [local count: 36019]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _26 = new_ipaddr.u_addr.ip6.addr[0];
  netif_4(D)->ip6_addr[_13].u_addr.ip6.addr[0] = _26;
  # DEBUG BEGIN_STMT
  _27 = new_ipaddr.u_addr.ip6.addr[1];
  netif_4(D)->ip6_addr[_13].u_addr.ip6.addr[1] = _27;
  # DEBUG BEGIN_STMT
  _28 = new_ipaddr.u_addr.ip6.addr[2];
  netif_4(D)->ip6_addr[_13].u_addr.ip6.addr[2] = _28;
  # DEBUG BEGIN_STMT
  _29 = new_ipaddr.u_addr.ip6.addr[3];
  netif_4(D)->ip6_addr[_13].u_addr.ip6.addr[3] = _29;
  # DEBUG BEGIN_STMT
  _30 = new_ipaddr.u_addr.ip6.zone;
  netif_4(D)->ip6_addr[_13].u_addr.ip6.zone = _30;
  # DEBUG BEGIN_STMT
  goto <bb 17>; [100.00%]

  <bb 16> [local count: 69920]:
  # DEBUG BEGIN_STMT
  _31 = new_ipaddr.u_addr.ip4.addr;
  netif_4(D)->ip6_addr[_13].u_addr.ip4.addr = _31;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_4(D)->ip6_addr[_13].u_addr.ip6.addr[3] = 0;
  netif_4(D)->ip6_addr[_13].u_addr.ip6.addr[2] = 0;
  netif_4(D)->ip6_addr[_13].u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  netif_4(D)->ip6_addr[_13].u_addr.ip6.zone = 0;

  <bb 17> [local count: 105939]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _32 = netif_4(D)->ip6_addr_state[_13];
  _33 = _32 & 16;
  if (_33 != 0)
    goto <bb 18>; [33.00%]
  else
    goto <bb 19>; [67.00%]

  <bb 18> [local count: 34960]:
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif_4(D), 2);

  <bb 19> [local count: 107374]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_ipaddr ={v} {CLOBBER};
  # DEBUG netif => NULL
  # DEBUG addr_idx => NULL
  # DEBUG i0 => NULL
  # DEBUG i1 => NULL
  # DEBUG i2 => NULL
  # DEBUG i3 => NULL
  # DEBUG old_addr$u_addr$ip6$addr$0 => NULL
  # DEBUG old_addr$u_addr$ip6$addr$1 => NULL
  # DEBUG old_addr$u_addr$ip6$addr$2 => NULL
  # DEBUG old_addr$u_addr$ip6$addr$3 => NULL
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_ip6_addr_set (netif_ip6_addr_set, funcdef_no=21, decl_uid=6839, cgraph_uid=22, symbol_order=25)

netif_ip6_addr_set (struct netif * netif, s8_t addr_idx, const struct ip6_addr_t * addr6)
{
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;

  <bb 2> [local count: 329661]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_7(D) == 0B)
    goto <bb 7>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 7> [local count: 98898]:

  <bb 3> [local count: 988985746]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 9> [local count: 988985746]:
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 230763]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (addr6_9(D) == 0B)
    goto <bb 8>; [46.53%]
  else
    goto <bb 6>; [53.47%]

  <bb 8> [local count: 107374]:

  <bb 5> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 10> [local count: 1073741824]:
  goto <bb 5>; [100.00%]

  <bb 6> [local count: 123389]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = addr6_9(D)->addr[0];
  _2 = addr6_9(D)->addr[1];
  _3 = addr6_9(D)->addr[2];
  _4 = addr6_9(D)->addr[3];
  netif_ip6_addr_set_parts (netif_7(D), addr_idx_10(D), _1, _2, _3, _4);
  return;

}



;; Function netif_ip6_addr_set_state (netif_ip6_addr_set_state, funcdef_no=23, decl_uid=6850, cgraph_uid=24, symbol_order=27)


Symbols to be put in SSA form
{ D.8389 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 24
Number of blocks to update: 23 ( 96%)


Merging blocks 3 and 9
Merging blocks 5 and 10
Removing basic block 6
Removing basic block 7
Removing basic block 8
Removing basic block 12
Merging blocks 23 and 11
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
;;
;; Loop 2
;;  header 3, latch 3
;;  depth 1, outer 0
;;  nodes: 3
;;
;; Loop 1
;;  header 5, latch 5
;;  depth 1, outer 0
;;  nodes: 5
;; 2 succs { 3 4 }
;; 3 succs { 3 }
;; 4 succs { 5 6 }
;; 5 succs { 5 }
;; 6 succs { 7 16 }
;; 7 succs { 8 9 }
;; 8 succs { 9 }
;; 9 succs { 10 12 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 15 }
;; 13 succs { 14 15 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 1 }
netif_ip6_addr_set_state (struct netif * netif, s8_t addr_idx, u8_t state)
{
  u8_t new_valid;
  u8_t old_valid;
  u8_t old_state;
  int _10;
  unsigned char _14;
  unsigned char _15;
  struct ip_addr_t * _16;

  <bb 2> [local count: 306783]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_4(D) == 0B)
    goto <bb 3>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 3> [local count: 920350134]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 214748]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (addr_idx_6(D) > 2)
    goto <bb 5>; [50.00%]
  else
    goto <bb 6>; [50.00%]

  <bb 5> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [100.00%]

  <bb 6> [local count: 107374]:
  # DEBUG netif => netif_4(D)
  # DEBUG addr_idx => addr_idx_6(D)
  # DEBUG state => state_7(D)
  # DEBUG INLINE_ENTRY netif_ip6_addr_set_state
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _10 = (int) addr_idx_6(D);
  old_state_11 = netif_4(D)->ip6_addr_state[_10];
  # DEBUG old_state => old_state_11
  # DEBUG BEGIN_STMT
  if (state_7(D) != old_state_11)
    goto <bb 7>; [66.00%]
  else
    goto <bb 16>; [34.00%]

  <bb 7> [local count: 70867]:
  # DEBUG BEGIN_STMT
  old_valid_12 = old_state_11 & 16;
  # DEBUG old_valid => old_valid_12
  # DEBUG BEGIN_STMT
  new_valid_13 = state_7(D) & 16;
  # DEBUG new_valid => new_valid_13
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _14 = netif_4(D)->flags;
  _15 = _14 & 64;
  if (_15 != 0)
    goto <bb 8>; [33.00%]
  else
    goto <bb 9>; [67.00%]

  <bb 8> [local count: 23386]:
  # DEBUG BEGIN_STMT
  nd6_adjust_mld_membership (netif_4(D), addr_idx_6(D), state_7(D));

  <bb 9> [local count: 70867]:
  # DEBUG BEGIN_STMT
  if (old_valid_12 != 0)
    goto <bb 10>; [50.00%]
  else
    goto <bb 12>; [50.00%]

  <bb 10> [local count: 35433]:
  if (new_valid_13 == 0)
    goto <bb 11>; [33.00%]
  else
    goto <bb 12>; [67.00%]

  <bb 11> [local count: 11693]:
  # DEBUG BEGIN_STMT
  _16 = &netif_4(D)->ip6_addr[_10];
  netif_do_ip_addr_changed (_16, 0B);

  <bb 12> [local count: 70867]:
  # DEBUG BEGIN_STMT
  netif_4(D)->ip6_addr_state[_10] = state_7(D);
  # DEBUG BEGIN_STMT
  if (old_valid_12 == 0)
    goto <bb 13>; [50.00%]
  else
    goto <bb 15>; [50.00%]

  <bb 13> [local count: 35433]:
  if (new_valid_13 != 0)
    goto <bb 14>; [33.00%]
  else
    goto <bb 15>; [67.00%]

  <bb 14> [local count: 11693]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif_4(D), 2);

  <bb 15> [local count: 70867]:
  # DEBUG BEGIN_STMT

  <bb 16> [local count: 107374]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG netif => NULL
  # DEBUG addr_idx => NULL
  # DEBUG state => NULL
  # DEBUG old_state => NULL
  # DEBUG old_valid => NULL
  # DEBUG new_valid => NULL
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  return;

}



;; Function netif_get_ip6_addr_match (netif_get_ip6_addr_match, funcdef_no=24, decl_uid=6853, cgraph_uid=25, symbol_order=28)


Symbols to be put in SSA form
{ D.8390 D.8644 }
Incremental SSA update started at block: 0
Number of blocks in CFG: 26
Number of blocks to update: 25 ( 96%)


Merging blocks 3 and 12
Merging blocks 5 and 13
Merging blocks 8 and 15
Removing basic block 10
Removing basic block 11
Merging blocks 25 and 14
Merging blocks 8 and 16
;; 5 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;;
;; Loop 3
;;  header 3, latch 3
;;  depth 1, outer 0
;;  nodes: 3
;;
;; Loop 2
;;  header 5, latch 5
;;  depth 1, outer 0
;;  nodes: 5
;;
;; Loop 4
;;  header 16, latch 15
;;  depth 1, outer 0
;;  nodes: 16 15 9 10 11 12 13
;; 2 succs { 3 4 }
;; 3 succs { 3 }
;; 4 succs { 5 6 }
;; 5 succs { 5 }
;; 6 succs { 7 8 }
;; 7 succs { 18 8 }
;; 8 succs { 16 }
;; 9 succs { 10 15 }
;; 10 succs { 11 15 }
;; 11 succs { 12 15 }
;; 12 succs { 13 15 }
;; 13 succs { 14 15 }
;; 14 succs { 17 }
;; 15 succs { 16 }
;; 16 succs { 9 17 }
;; 17 succs { 18 }
;; 18 succs { 1 }
netif_get_ip6_addr_match (struct netif * netif, const struct ip6_addr_t * ip6addr)
{
  s8_t i;
  s8_t D.8644;
  s8_t i;
  unsigned char _1;
  unsigned char _3;
  unsigned char _4;
  signed char _5;
  s8_t _8;
  int _17;
  unsigned char _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  long unsigned int _22;
  long unsigned int _23;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  unsigned char i.14_27;
  unsigned char _28;
  signed char _30;

  <bb 2> [local count: 357913]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_11(D) == 0B)
    goto <bb 3>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 3> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 250539]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ip6addr_13(D) == 0B)
    goto <bb 5>; [30.00%]
  else
    goto <bb 6>; [70.00%]

  <bb 5> [local count: 751619279]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [100.00%]

  <bb 6> [local count: 175378]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = ip6addr_13(D)->zone;
  if (_1 != 0)
    goto <bb 7>; [50.00%]
  else
    goto <bb 8>; [50.00%]

  <bb 7> [local count: 87689]:
  _3 = netif_11(D)->num;
  _4 = _3 + 1;
  if (_1 != _4)
    goto <bb 18>; [2.00%]
  else
    goto <bb 8>; [98.00%]

  <bb 8> [local count: 173624]:
  # i_2 = PHI <0(7), 0(6)>
  # DEBUG netif => netif_11(D)
  # DEBUG ip6addr => ip6addr_13(D)
  # DEBUG INLINE_ENTRY netif_get_ip6_addr_match
  goto <bb 16>; [100.00%]

  <bb 9> [local count: 519188]:
  # DEBUG BEGIN_STMT
  _17 = (int) i_16;
  _18 = netif_11(D)->ip6_addr_state[_17];
  if (_18 != 0)
    goto <bb 10>; [50.00%]
  else
    goto <bb 15>; [50.00%]

  <bb 10> [local count: 259594]:
  _19 = MEM[(const struct ip6_addr_t *)netif_11(D)].ip6_addr[_17].u_addr.ip6.addr[0];
  _20 = ip6addr_13(D)->addr[0];
  if (_19 == _20)
    goto <bb 11>; [34.00%]
  else
    goto <bb 15>; [66.00%]

  <bb 11> [local count: 88262]:
  _21 = MEM[(const struct ip6_addr_t *)netif_11(D)].ip6_addr[_17].u_addr.ip6.addr[1];
  _22 = ip6addr_13(D)->addr[1];
  if (_21 == _22)
    goto <bb 12>; [34.00%]
  else
    goto <bb 15>; [66.00%]

  <bb 12> [local count: 30009]:
  _23 = MEM[(const struct ip6_addr_t *)netif_11(D)].ip6_addr[_17].u_addr.ip6.addr[2];
  _24 = ip6addr_13(D)->addr[2];
  if (_23 == _24)
    goto <bb 13>; [34.00%]
  else
    goto <bb 15>; [66.00%]

  <bb 13> [local count: 10203]:
  _25 = MEM[(const struct ip6_addr_t *)netif_11(D)].ip6_addr[_17].u_addr.ip6.addr[3];
  _26 = ip6addr_13(D)->addr[3];
  if (_25 == _26)
    goto <bb 14>; [5.50%]
  else
    goto <bb 15>; [94.50%]

  <bb 14> [local count: 561]:
  # i_32 = PHI <i_16(13)>
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [100.00%]

  <bb 15> [local count: 518627]:
  # DEBUG BEGIN_STMT
  i.14_27 = (unsigned char) i_16;
  _28 = i.14_27 + 1;
  i_29 = (s8_t) _28;
  # DEBUG i => i_29

  <bb 16> [local count: 692250]:
  # i_16 = PHI <0(8), i_29(15)>
  # DEBUG i => i_16
  # DEBUG BEGIN_STMT
  if (i_16 != 3)
    goto <bb 9>; [75.00%]
  else
    goto <bb 17>; [25.00%]

  <bb 17> [local count: 173624]:
  # _30 = PHI <i_32(14), -1(16)>
  _33 = _30;
  # DEBUG netif => NULL
  # DEBUG ip6addr => NULL
  # DEBUG i => NULL
  _5 = _33;

  <bb 18> [local count: 175378]:
  # _8 = PHI <-1(7), _5(17)>
  return _8;

}



;; Function netif_create_ip6_linklocal_address (netif_create_ip6_linklocal_address, funcdef_no=25, decl_uid=6856, cgraph_uid=26, symbol_order=29)

netif_create_ip6_linklocal_address (struct netif * netif, u8_t from_mac_48bit)
{
  u8_t addr_index;
  u8_t i;
  unsigned char _1;
  unsigned char _2;
  long unsigned int _3;
  long unsigned int _4;
  unsigned char _5;
  long unsigned int _6;
  long unsigned int _7;
  long unsigned int _8;
  unsigned char _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  long unsigned int _14;
  unsigned char _15;
  long unsigned int _16;
  long unsigned int _17;
  unsigned char _18;
  long unsigned int _19;
  long unsigned int _20;
  long unsigned int _21;
  unsigned char _22;
  long unsigned int _23;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  int _27;
  int _28;
  int _29;
  int _30;
  unsigned char _31;
  long unsigned int _32;
  int _33;
  int _34;
  long unsigned int _35;
  int _36;
  long unsigned int _37;
  long unsigned int _38;
  unsigned char _39;
  long unsigned int _40;
  long unsigned int _41;
  unsigned char _42;
  u8_t iftmp.17_46;
  unsigned char _57;
  long unsigned int _60;
  u8_t iftmp.17_67;

  <bb 2> [local count: 357913]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_50(D) == 0B)
    goto <bb 15>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 15> [local count: 107374]:

  <bb 3> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 16> [local count: 1073741824]:
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 250539]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_50(D)->ip6_addr[0].u_addr.ip6.addr[0] = 33022;
  # DEBUG BEGIN_STMT
  netif_50(D)->ip6_addr[0].u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  if (from_mac_48bit_54(D) != 0)
    goto <bb 5>; [33.00%]
  else
    goto <bb 6>; [67.00%]

  <bb 5> [local count: 82678]:
  # DEBUG BEGIN_STMT
  _1 = netif_50(D)->hwaddr[0];
  _2 = _1 ^ 2;
  _3 = (long unsigned int) _2;
  _4 = _3 << 24;
  _5 = netif_50(D)->hwaddr[1];
  _6 = (long unsigned int) _5;
  _7 = _6 << 16;
  _8 = _4 | _7;
  _9 = netif_50(D)->hwaddr[2];
  _10 = (long unsigned int) _9;
  _11 = _10 << 8;
  _12 = _8 | _11;
  _13 = _12 | 255;
  _14 = lwip_htonl (_13);
  netif_50(D)->ip6_addr[0].u_addr.ip6.addr[2] = _14;
  # DEBUG BEGIN_STMT
  _15 = netif_50(D)->hwaddr[3];
  _16 = (long unsigned int) _15;
  _17 = _16 << 16;
  _18 = netif_50(D)->hwaddr[4];
  _19 = (long unsigned int) _18;
  _20 = _19 << 8;
  _21 = _17 | _20;
  _22 = netif_50(D)->hwaddr[5];
  _23 = (long unsigned int) _22;
  _24 = _21 | _23;
  _25 = _24 | 4261412864;
  _26 = lwip_htonl (_25);
  netif_50(D)->ip6_addr[0].u_addr.ip6.addr[3] = _26;
  goto <bb 12>; [100.00%]

  <bb 6> [local count: 167861]:
  # DEBUG BEGIN_STMT
  netif_50(D)->ip6_addr[0].u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif_50(D)->ip6_addr[0].u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  # DEBUG addr_index => 3
  # DEBUG BEGIN_STMT
  # DEBUG i => 0
  goto <bb 10>; [100.00%]

  <bb 7> [local count: 881341]:
  # DEBUG BEGIN_STMT
  if (i_43 == 4)
    goto <bb 8>; [22.47%]
  else
    goto <bb 9>; [77.53%]

  <bb 8> [local count: 198037]:
  # DEBUG BEGIN_STMT
  addr_index_58 = addr_index_45 + 255;
  # DEBUG addr_index => addr_index_58

  <bb 9> [local count: 881341]:
  # addr_index_44 = PHI <addr_index_45(7), addr_index_58(8)>
  # DEBUG addr_index => addr_index_44
  # DEBUG BEGIN_STMT
  _27 = (int) _39;
  _28 = (int) i_43;
  _29 = _27 - _28;
  _30 = _29 + -1;
  _31 = netif_50(D)->hwaddr[_30];
  _32 = (long unsigned int) _31;
  _57 = i_43 & 3;
  _33 = (int) _57;
  _34 = _33 * 8;
  _35 = _32 << _34;
  _60 = lwip_htonl (_35);
  _36 = (int) addr_index_44;
  _37 = netif_50(D)->ip6_addr[0].u_addr.ip6.addr[_36];
  _38 = _37 | _60;
  netif_50(D)->ip6_addr[0].u_addr.ip6.addr[_36] = _38;
  # DEBUG BEGIN_STMT
  i_62 = i_43 + 1;
  # DEBUG i => i_62

  <bb 10> [local count: 1049202]:
  # i_43 = PHI <0(6), i_62(9)>
  # addr_index_45 = PHI <3(6), addr_index_44(9)>
  # DEBUG addr_index => addr_index_45
  # DEBUG i => i_43
  # DEBUG BEGIN_STMT
  if (i_43 != 8)
    goto <bb 11>; [88.89%]
  else
    goto <bb 12>; [11.11%]

  <bb 11> [local count: 932636]:
  _39 = netif_50(D)->hwaddr_len;
  if (_39 > i_43)
    goto <bb 7>; [94.50%]
  else
    goto <bb 12>; [5.50%]

  <bb 12> [local count: 250539]:
  # DEBUG BEGIN_STMT
  _40 = netif_50(D)->ip6_addr[0].u_addr.ip6.addr[0];
  _41 = _40 & 49407;
  if (_41 == 33022)
    goto <bb 13>; [34.00%]
  else
    goto <bb 14>; [66.00%]

  <bb 13> [local count: 85183]:
  _42 = netif_50(D)->num;
  iftmp.17_67 = _42 + 1;

  <bb 14> [local count: 250539]:
  # iftmp.17_46 = PHI <iftmp.17_67(13), 0(12)>
  netif_50(D)->ip6_addr[0].u_addr.ip6.zone = iftmp.17_46;
  # DEBUG BEGIN_STMT
  netif_ip6_addr_set_state (netif_50(D), 0, 8);
  return;

}



;; Function netif_add_ip6_address (netif_add_ip6_address, funcdef_no=26, decl_uid=6860, cgraph_uid=27, symbol_order=30)

netif_add_ip6_address (struct netif * netif, const struct ip6_addr_t * ip6addr, s8_t * chosen_idx)
{
  s8_t i;
  long unsigned int _1;
  long unsigned int _2;
  _Bool _3;
  int _4;
  unsigned char _5;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  unsigned char _10;
  long unsigned int _11;
  long unsigned int _12;
  unsigned char _13;
  int _14;
  unsigned char i.20_15;
  unsigned char _16;
  err_t _18;
  u8_t iftmp.18_19;
  u8_t iftmp.18_40;

  <bb 2> [local count: 329661]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif_25(D) == 0B)
    goto <bb 22>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 22> [local count: 98898]:

  <bb 3> [local count: 988985746]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 24> [local count: 988985746]:
  goto <bb 3>; [100.00%]

  <bb 4> [local count: 230763]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ip6addr_27(D) == 0B)
    goto <bb 23>; [46.53%]
  else
    goto <bb 6>; [53.47%]

  <bb 23> [local count: 107374]:

  <bb 5> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT

  <bb 25> [local count: 1073741824]:
  goto <bb 5>; [100.00%]

  <bb 6> [local count: 123389]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i_29 = netif_get_ip6_addr_match (netif_25(D), ip6addr_27(D));
  # DEBUG i => i_29
  # DEBUG BEGIN_STMT
  if (i_29 >= 0)
    goto <bb 7>; [42.57%]
  else
    goto <bb 10>; [57.43%]

  <bb 7> [local count: 52527]:
  # DEBUG BEGIN_STMT
  if (chosen_idx_31(D) != 0B)
    goto <bb 8>; [70.00%]
  else
    goto <bb 9>; [30.00%]

  <bb 8> [local count: 36769]:
  # DEBUG BEGIN_STMT
  *chosen_idx_31(D) = i_29;

  <bb 9> [local count: 52527]:
  # DEBUG BEGIN_STMT
  goto <bb 21>; [100.00%]

  <bb 10> [local count: 70862]:
  # DEBUG BEGIN_STMT
  _1 = ip6addr_27(D)->addr[0];
  _2 = _1 & 49407;
  _3 = _2 != 33022;
  i_30 = (s8_t) _3;
  # DEBUG i => i_30
  goto <bb 18>; [100.00%]

  <bb 11> [local count: 625986]:
  # DEBUG BEGIN_STMT
  _4 = (int) i_17;
  _5 = netif_25(D)->ip6_addr_state[_4];
  if (_5 == 0)
    goto <bb 12>; [5.50%]
  else
    goto <bb 17>; [94.50%]

  <bb 12> [local count: 34429]:
  # _14 = PHI <_4(11)>
  # i_6 = PHI <i_17(11)>
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_25(D)->ip6_addr[_14].u_addr.ip6.addr[0] = _1;
  # DEBUG BEGIN_STMT
  _7 = ip6addr_27(D)->addr[1];
  netif_25(D)->ip6_addr[_14].u_addr.ip6.addr[1] = _7;
  # DEBUG BEGIN_STMT
  _8 = ip6addr_27(D)->addr[2];
  netif_25(D)->ip6_addr[_14].u_addr.ip6.addr[2] = _8;
  # DEBUG BEGIN_STMT
  _9 = ip6addr_27(D)->addr[3];
  netif_25(D)->ip6_addr[_14].u_addr.ip6.addr[3] = _9;
  # DEBUG BEGIN_STMT
  _10 = ip6addr_27(D)->zone;
  netif_25(D)->ip6_addr[_14].u_addr.ip6.zone = _10;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_25(D)->ip6_addr[_14].type = 6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _11 = netif_25(D)->ip6_addr[_14].u_addr.ip6.addr[0];
  _12 = _11 & 49407;
  if (_12 == 33022)
    goto <bb 13>; [34.00%]
  else
    goto <bb 14>; [66.00%]

  <bb 13> [local count: 11706]:
  _13 = netif_25(D)->num;
  iftmp.18_40 = _13 + 1;

  <bb 14> [local count: 34429]:
  # iftmp.18_19 = PHI <iftmp.18_40(13), 0(12)>
  netif_25(D)->ip6_addr[_14].u_addr.ip6.zone = iftmp.18_19;
  # DEBUG BEGIN_STMT
  netif_ip6_addr_set_state (netif_25(D), i_6, 8);
  # DEBUG BEGIN_STMT
  if (chosen_idx_31(D) != 0B)
    goto <bb 15>; [70.00%]
  else
    goto <bb 16>; [30.00%]

  <bb 15> [local count: 24100]:
  # DEBUG BEGIN_STMT
  *chosen_idx_31(D) = i_6;

  <bb 16> [local count: 34429]:
  # DEBUG BEGIN_STMT
  goto <bb 21>; [100.00%]

  <bb 17> [local count: 591557]:
  # DEBUG BEGIN_STMT
  i.20_15 = (unsigned char) i_17;
  _16 = i.20_15 + 1;
  i_33 = (s8_t) _16;
  # DEBUG i => i_33

  <bb 18> [local count: 662419]:
  # i_17 = PHI <i_30(10), i_33(17)>
  # DEBUG i => i_17
  # DEBUG BEGIN_STMT
  if (i_17 <= 2)
    goto <bb 11>; [94.50%]
  else
    goto <bb 19>; [5.50%]

  <bb 19> [local count: 36433]:
  # DEBUG BEGIN_STMT
  if (chosen_idx_31(D) != 0B)
    goto <bb 20>; [70.00%]
  else
    goto <bb 21>; [30.00%]

  <bb 20> [local count: 25503]:
  # DEBUG BEGIN_STMT
  *chosen_idx_31(D) = -1;

  <bb 21> [local count: 123389]:
  # _18 = PHI <0(9), 0(16), -6(20), -6(19)>
  return _18;

}



;; Function netif_get_by_index (netif_get_by_index, funcdef_no=31, decl_uid=6867, cgraph_uid=32, symbol_order=35)

netif_get_by_index (u8_t idx)
{
  struct netif * netif;
  unsigned char _1;
  unsigned char _2;
  struct netif * _4;

  <bb 2> [local count: 161779623]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (idx_5(D) != 0)
    goto <bb 3>; [71.00%]
  else
    goto <bb 8>; [29.00%]

  <bb 3> [local count: 114863532]:
  # DEBUG BEGIN_STMT
  netif_7 = netif_list;
  # DEBUG netif => netif_7
  goto <bb 7>; [100.00%]

  <bb 4> [local count: 1014686024]:
  # DEBUG BEGIN_STMT
  _1 = netif_3->num;
  _2 = _1 + 1;
  if (_2 == idx_5(D))
    goto <bb 5>; [5.50%]
  else
    goto <bb 6>; [94.50%]

  <bb 5> [local count: 55807731]:
  # netif_9 = PHI <netif_3(4)>
  # DEBUG BEGIN_STMT
  goto <bb 8>; [100.00%]

  <bb 6> [local count: 958878293]:
  # DEBUG BEGIN_STMT
  netif_8 = netif_3->next;
  # DEBUG netif => netif_8

  <bb 7> [local count: 1073741824]:
  # netif_3 = PHI <netif_7(3), netif_8(6)>
  # DEBUG netif => netif_3
  # DEBUG BEGIN_STMT
  if (netif_3 != 0B)
    goto <bb 4>; [94.50%]
  else
    goto <bb 8>; [5.50%]

  <bb 8> [local count: 161779622]:
  # _4 = PHI <netif_9(5), 0B(7), 0B(2)>
  return _4;

}



;; Function netif_index_to_name (netif_index_to_name, funcdef_no=30, decl_uid=6865, cgraph_uid=31, symbol_order=34)

netif_index_to_name (u8_t idx, char * name)
{
  struct netif * netif;
  char _1;
  char _2;
  char * _3;
  int _4;
  int _5;
  char * _6;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  netif_10 = netif_get_by_index (idx_9(D));
  # DEBUG netif => netif_10
  # DEBUG BEGIN_STMT
  if (netif_10 != 0B)
    goto <bb 3>; [59.18%]
  else
    goto <bb 4>; [40.82%]

  <bb 3> [local count: 635440412]:
  # DEBUG BEGIN_STMT
  _1 = netif_10->name[0];
  *name_11(D) = _1;
  # DEBUG BEGIN_STMT
  _2 = netif_10->name[1];
  MEM[(char *)name_11(D) + 1B] = _2;
  # DEBUG BEGIN_STMT
  _3 = name_11(D) + 2;
  _4 = (int) idx_9(D);
  _5 = _4 + -1;
  lwip_itoa (_3, 4, _5);
  # DEBUG BEGIN_STMT

  <bb 4> [local count: 1073741824]:
  # _6 = PHI <name_11(D)(3), 0B(2)>
  return _6;

}



;; Function netif_find (netif_find, funcdef_no=32, decl_uid=6813, cgraph_uid=33, symbol_order=36)

netif_find (const char * name)
{
  u8_t num;
  struct netif * netif;
  const char * _1;
  int _2;
  char _3;
  unsigned char _4;
  char _5;
  char _6;
  char _7;
  char _8;
  struct netif * _10;

  <bb 2> [local count: 90638327]:
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (name_12(D) == 0B)
    goto <bb 12>; [15.47%]
  else
    goto <bb 3>; [84.53%]

  <bb 3> [local count: 76616578]:
  # DEBUG BEGIN_STMT
  _1 = name_12(D) + 2;
  _2 = atoi (_1);
  num_15 = (u8_t) _2;
  # DEBUG num => num_15
  # DEBUG BEGIN_STMT
  if (num_15 == 0)
    goto <bb 4>; [50.00%]
  else
    goto <bb 5>; [50.00%]

  <bb 4> [local count: 38308289]:
  _3 = MEM[(const char *)name_12(D) + 2B];
  if (_3 != 48)
    goto <bb 12>; [29.00%]
  else
    goto <bb 5>; [71.00%]

  <bb 5> [local count: 65507174]:
  # DEBUG BEGIN_STMT
  netif_16 = netif_list;
  # DEBUG netif => netif_16
  goto <bb 11>; [100.00%]

  <bb 6> [local count: 1014686025]:
  # DEBUG BEGIN_STMT
  _4 = netif_9->num;
  if (_4 == num_15)
    goto <bb 7>; [34.00%]
  else
    goto <bb 10>; [66.00%]

  <bb 7> [local count: 344993248]:
  _5 = *name_12(D);
  _6 = netif_9->name[0];
  if (_5 == _6)
    goto <bb 8>; [34.00%]
  else
    goto <bb 10>; [66.00%]

  <bb 8> [local count: 117297704]:
  _7 = MEM[(const char *)name_12(D) + 1B];
  _8 = netif_9->name[1];
  if (_7 == _8)
    goto <bb 9>; [5.50%]
  else
    goto <bb 10>; [94.50%]

  <bb 9> [local count: 6451374]:
  # netif_17 = PHI <netif_9(8)>
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  goto <bb 12>; [100.00%]

  <bb 10> [local count: 1008234651]:
  # DEBUG BEGIN_STMT
  netif_18 = netif_9->next;
  # DEBUG netif => netif_18

  <bb 11> [local count: 1073741824]:
  # netif_9 = PHI <netif_16(5), netif_18(10)>
  # DEBUG netif => netif_9
  # DEBUG BEGIN_STMT
  if (netif_9 != 0B)
    goto <bb 6>; [94.50%]
  else
    goto <bb 12>; [5.50%]

  <bb 12> [local count: 90638327]:
  # _10 = PHI <0B(2), 0B(4), netif_17(9), 0B(11)>
  return _10;

}



;; Function netif_name_to_index (netif_name_to_index, funcdef_no=29, decl_uid=6862, cgraph_uid=30, symbol_order=33)

netif_name_to_index (const char * name)
{
  struct netif * netif;
  unsigned char _1;
  u8_t _2;
  u8_t _7;

  <bb 2> [local count: 1073741824]:
  # DEBUG BEGIN_STMT
  netif_6 = netif_find (name_4(D));
  # DEBUG netif => netif_6
  # DEBUG BEGIN_STMT
  if (netif_6 != 0B)
    goto <bb 3>; [54.59%]
  else
    goto <bb 4>; [45.41%]

  <bb 3> [local count: 586155663]:
  # DEBUG BEGIN_STMT
  _1 = netif_6->num;
  _7 = _1 + 1;

  <bb 4> [local count: 1073741824]:
  # _2 = PHI <_7(3), 0(2)>
  return _2;

}



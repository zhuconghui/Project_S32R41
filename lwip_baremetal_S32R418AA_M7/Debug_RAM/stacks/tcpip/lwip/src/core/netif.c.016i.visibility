
Marking local functions: netif_issue_reports netif_do_set_gw netif_do_set_netmask netif_do_set_ipaddr netif_do_ip_addr_changed


Marking externally visible functions: netif_find netif_get_by_index netif_index_to_name netif_name_to_index netif_add_ip6_address netif_create_ip6_linklocal_address netif_get_ip6_addr_match netif_ip6_addr_set_state netif_ip6_addr_set_parts netif_ip6_addr_set netif_alloc_client_data_id netif_set_link_down netif_set_link_up netif_set_down netif_set_up netif_set_default netif_remove netif_set_addr netif_set_gw netif_set_netmask netif_set_ipaddr netif_add netif_add_noaddr netif_input netif_init


Marking externally visible variables: netif_default netif_list


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

atoi/57 (atoi) @06ea3ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_find/36 
  Calls: 
lwip_itoa/56 (lwip_itoa) @06ea3c40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_index_to_name/34 
  Calls: 
lwip_htonl/55 (lwip_htonl) @06ea37e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_create_ip6_linklocal_address/29 netif_create_ip6_linklocal_address/29 netif_create_ip6_linklocal_address/29 
  Calls: 
nd6_adjust_mld_membership/54 (nd6_adjust_mld_membership) @06ea3460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_ip6_addr_set_state/27 
  Calls: 
nd6_cleanup_netif/53 (nd6_cleanup_netif) @06e6cd20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_set_down/21 
  Calls: 
etharp_cleanup_netif/52 (etharp_cleanup_netif) @06e6cc40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_set_down/21 
  Calls: 
sys_now/51 (sys_now) @06e6ca80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_set_down/21 netif_set_up/19 
  Calls: 
mld6_stop/50 (mld6_stop) @06e6c7e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_remove/17 
  Calls: 
igmp_stop/49 (igmp_stop) @06e6c700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_remove/17 
  Calls: 
mld6_report_groups/48 (mld6_report_groups) @06e19ee0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_issue_reports/20 
  Calls: 
igmp_report_groups/47 (igmp_report_groups) @06e19e00
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_issue_reports/20 
  Calls: 
etharp_request/46 (etharp_request) @06e19d20
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_issue_reports/20 
  Calls: 
raw_netif_ip_addr_changed/45 (raw_netif_ip_addr_changed) @06e19b60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_do_ip_addr_changed/9 
  Calls: 
udp_netif_ip_addr_changed/44 (udp_netif_ip_addr_changed) @06e19a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_do_ip_addr_changed/9 
  Calls: 
tcp_netif_ip_addr_changed/43 (tcp_netif_ip_addr_changed) @06e199a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_do_ip_addr_changed/9 
  Calls: 
igmp_start/42 (igmp_start) @06e19460
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_add/8 
  Calls: 
nd6_restart_netif/41 (nd6_restart_netif) @06e192a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_set_link_up/22 netif_set_up/19 netif_add/8 
  Calls: 
memset/40 (memset) @06e191c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_add/8 
  Calls: 
ip_addr_any/39 (ip_addr_any) @06e1a0d8
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: netif_add/8 (addr)netif_add/8 (addr)netif_add/8 (addr)netif_set_ipaddr/11 (addr)netif_set_netmask/13 (addr)netif_set_gw/15 (addr)netif_set_addr/16 (addr)netif_set_addr/16 (addr)netif_set_addr/16 (addr)
  Availability: not_available
  Varpool flags: read-only
ip_input/38 (ip_input) @06e09380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_input/6 
  Calls: 
ethernet_input/37 (ethernet_input) @06e090e0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: netif_input/6 
  Calls: 
netif_find/36 (netif_find) @06e09a80
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_list/1 (read)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_name_to_index/33 
  Calls: atoi/57 
netif_get_by_index/35 (netif_get_by_index) @06e097e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_list/1 (read)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_index_to_name/34 
  Calls: 
netif_index_to_name/34 (netif_index_to_name) @06e09540
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: lwip_itoa/56 netif_get_by_index/35 
netif_name_to_index/33 (netif_name_to_index) @06e092a0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_find/36 
netif_null_output_ip4/32 (netif_null_output_ip4) @06e09000
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: 
  Referring: netif_add/8 (addr)
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
netif_null_output_ip6/31 (netif_null_output_ip6) @06ded700
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: 
  Referring: netif_add/8 (addr)
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
netif_add_ip6_address/30 (netif_add_ip6_address) @06dedd20
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_ip6_addr_set_state/27 netif_get_ip6_addr_match/28 
netif_create_ip6_linklocal_address/29 (netif_create_ip6_linklocal_address) @06ded620
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_ip6_addr_set_state/27 lwip_htonl/55 lwip_htonl/55 lwip_htonl/55 
netif_get_ip6_addr_match/28 (netif_get_ip6_addr_match) @06de7ee0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_add_ip6_address/30 
  Calls: 
netif_ip6_addr_set_state/27 (netif_ip6_addr_set_state) @06de78c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_add_ip6_address/30 netif_create_ip6_linklocal_address/29 
  Calls: netif_issue_reports/20 netif_do_ip_addr_changed/9 nd6_adjust_mld_membership/54 
netif_ip6_addr_set_parts/26 (netif_ip6_addr_set_parts) @06de7540
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_ip6_addr_set/25 
  Calls: netif_issue_reports/20 netif_do_ip_addr_changed/9 
netif_ip6_addr_set/25 (netif_ip6_addr_set) @06dc17e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_ip6_addr_set_parts/26 
netif_alloc_client_data_id/24 (netif_alloc_client_data_id) @06dc1540
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_client_id/4 (read)netif_client_id/4 (read)netif_client_id/4 (write)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
netif_set_link_down/23 (netif_set_link_down) @06dc12a0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
netif_set_link_up/22 (netif_set_link_up) @06dc1000
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: nd6_restart_netif/41 netif_issue_reports/20 
netif_set_down/21 (netif_set_down) @06db78c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_remove/17 
  Calls: nd6_cleanup_netif/53 etharp_cleanup_netif/52 sys_now/51 
netif_issue_reports/20 (netif_issue_reports) @06db7e00
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: netif_ip6_addr_set_state/27 netif_ip6_addr_set_parts/26 netif_set_link_up/22 netif_set_up/19 netif_do_set_ipaddr/10 
  Calls: mld6_report_groups/48 igmp_report_groups/47 etharp_request/46 
netif_set_up/19 (netif_set_up) @06db77e0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: nd6_restart_netif/41 netif_issue_reports/20 sys_now/51 
netif_set_default/18 (netif_set_default) @06db7460
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_default/2 (write)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_remove/17 
  Calls: 
netif_remove/17 (netif_remove) @06db71c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: netif_default/2 (read)netif_list/1 (read)netif_list/1 (write)netif_list/1 (read)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_set_default/18 netif_set_down/21 mld6_stop/50 netif_do_ip_addr_changed/9 igmp_stop/49 netif_do_ip_addr_changed/9 
netif_set_addr/16 (netif_set_addr) @06db1c40
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)ip_addr_any/39 (addr)ip_addr_any/39 (addr)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_add/8 
  Calls: netif_do_set_ipaddr/10 netif_do_set_gw/14 netif_do_set_netmask/12 netif_do_set_ipaddr/10 
netif_set_gw/15 (netif_set_gw) @06db18c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_do_set_gw/14 
netif_do_set_gw/14 (netif_do_set_gw) @06db1620
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: netif_set_addr/16 netif_set_gw/15 
  Calls: 
netif_set_netmask/13 (netif_set_netmask) @06db1000
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_do_set_netmask/12 
netif_do_set_netmask/12 (netif_do_set_netmask) @06da8ee0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: netif_set_addr/16 netif_set_netmask/13 
  Calls: 
netif_set_ipaddr/11 (netif_set_ipaddr) @06da88c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_do_set_ipaddr/10 
netif_do_set_ipaddr/10 (netif_do_set_ipaddr) @06da8620
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: netif_set_addr/16 netif_set_addr/16 netif_set_ipaddr/11 
  Calls: netif_issue_reports/20 netif_do_ip_addr_changed/9 
netif_do_ip_addr_changed/9 (netif_do_ip_addr_changed) @06d7c8c0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: netif_ip6_addr_set_state/27 netif_ip6_addr_set_parts/26 netif_remove/17 netif_remove/17 netif_do_set_ipaddr/10 
  Calls: raw_netif_ip_addr_changed/45 udp_netif_ip_addr_changed/44 tcp_netif_ip_addr_changed/43 
netif_add/8 (netif_add) @06d7c620
  Type: function definition analyzed
  Visibility: externally_visible public
  References: ip_addr_any/39 (addr)ip_addr_any/39 (addr)ip_addr_any/39 (addr)netif_null_output_ip4/32 (addr)netif_null_output_ip6/31 (addr)netif_num/3 (read)netif_list/1 (read)netif_num/3 (write)netif_num/3 (write)netif_list/1 (read)netif_list/1 (write)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: netif_add_noaddr/7 
  Calls: igmp_start/42 netif_set_addr/16 nd6_restart_netif/41 memset/40 
   Indirect call
netif_add_noaddr/7 (netif_add_noaddr) @06d61d20
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_add/8 
netif_input/6 (netif_input) @06d61ee0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: ip_input/38 ethernet_input/37 
netif_init/5 (netif_init) @06d61c40
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
netif_client_id/4 (netif_client_id) @06d5ad80
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: netif_alloc_client_data_id/24 (read)netif_alloc_client_data_id/24 (read)netif_alloc_client_data_id/24 (write)
  Availability: available
  Varpool flags:
netif_num/3 (netif_num) @06d5acf0
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: netif_add/8 (read)netif_add/8 (write)netif_add/8 (write)
  Availability: available
  Varpool flags:
netif_default/2 (netif_default) @06d5ac18
  Type: variable definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: netif_remove/17 (read)netif_set_default/18 (write)
  Availability: available
  Varpool flags:
netif_list/1 (netif_list) @06d5abd0
  Type: variable definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: netif_add/8 (read)netif_add/8 (read)netif_add/8 (write)netif_remove/17 (read)netif_remove/17 (write)netif_remove/17 (read)netif_get_by_index/35 (read)netif_find/36 (read)
  Availability: available
  Varpool flags:
netif_find (const char * name)
{
  u8_t num;
  struct netif * netif;
  struct netif * D.8353;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (name == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  D.8353 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _1 = name + 2;
  _2 = atoi (_1);
  num = (u8_t) _2;
  # DEBUG BEGIN_STMT
  if (num == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _3 = name + 2;
  _4 = *_3;
  if (_4 != 48)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  D.8353 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  netif = netif_list;
  goto <bb 13>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _5 = netif->num;
  if (num == _5)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 9> :
  _6 = *name;
  _7 = netif->name[0];
  if (_6 == _7)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _8 = name + 1;
  _9 = *_8;
  _10 = netif->name[1];
  if (_9 == _10)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8353 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  netif = netif->next;

  <bb 13> :
  # DEBUG BEGIN_STMT
  if (netif != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8353 = 0B;

  <bb 15> :
  return D.8353;

}


netif_get_by_index (u8_t idx)
{
  struct netif * netif;
  struct netif * D.8349;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (idx != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  netif = netif_list;
  goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _1 = netif->num;
  _2 = _1 + 1;
  if (idx == _2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  D.8349 = netif;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  netif = netif->next;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (netif != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  D.8349 = 0B;

  <bb 9> :
  return D.8349;

}


netif_index_to_name (u8_t idx, char * name)
{
  struct netif * netif;
  char * D.8343;

  <bb 2> :
  # DEBUG BEGIN_STMT
  netif = netif_get_by_index (idx);
  # DEBUG BEGIN_STMT
  if (netif != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = netif->name[0];
  *name = _1;
  # DEBUG BEGIN_STMT
  _2 = name + 1;
  _3 = netif->name[1];
  *_2 = _3;
  # DEBUG BEGIN_STMT
  _4 = name + 2;
  _5 = (int) idx;
  _6 = _5 + -1;
  lwip_itoa (_4, 4, _6);
  # DEBUG BEGIN_STMT
  D.8343 = name;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.8343 = 0B;

  <bb 5> :
  return D.8343;

}


netif_name_to_index (const char * name)
{
  struct netif * netif;
  u8_t D.8339;

  <bb 2> :
  # DEBUG BEGIN_STMT
  netif = netif_find (name);
  # DEBUG BEGIN_STMT
  if (netif != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = netif->num;
  D.8339 = _1 + 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.8339 = 0;

  <bb 5> :
  return D.8339;

}


netif_null_output_ip4 (struct netif * netif, struct pbuf * p, const struct ip4_addr_t * ipaddr)
{
  err_t D.8098;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8098 = -12;
  return D.8098;

}


netif_null_output_ip6 (struct netif * netif, struct pbuf * p, const struct ip6_addr_t * ipaddr)
{
  err_t D.8096;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8096 = -12;
  return D.8096;

}


netif_add_ip6_address (struct netif * netif, const struct ip6_addr_t * ip6addr, s8_t * chosen_idx)
{
  s8_t i;
  u8_t iftmp.18;
  err_t D.8325;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ip6addr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = netif_get_ip6_addr_match (netif, ip6addr);
  # DEBUG BEGIN_STMT
  if (i >= 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (chosen_idx != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  *chosen_idx = i;

  <bb 9> :
  # DEBUG BEGIN_STMT
  D.8325 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  _1 = ip6addr->addr[0];
  _2 = _1 & 49407;
  _3 = _2 != 33022;
  i = (s8_t) _3;
  goto <bb 19>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _4 = (int) i;
  _5 = netif->ip6_addr_state[_4];
  if (_5 == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _6 = (int) i;
  _7 = ip6addr->addr[0];
  netif->ip6_addr[_6].u_addr.ip6.addr[0] = _7;
  # DEBUG BEGIN_STMT
  _8 = (int) i;
  _9 = ip6addr->addr[1];
  netif->ip6_addr[_8].u_addr.ip6.addr[1] = _9;
  # DEBUG BEGIN_STMT
  _10 = (int) i;
  _11 = ip6addr->addr[2];
  netif->ip6_addr[_10].u_addr.ip6.addr[2] = _11;
  # DEBUG BEGIN_STMT
  _12 = (int) i;
  _13 = ip6addr->addr[3];
  netif->ip6_addr[_12].u_addr.ip6.addr[3] = _13;
  # DEBUG BEGIN_STMT
  _14 = (int) i;
  _15 = ip6addr->zone;
  netif->ip6_addr[_14].u_addr.ip6.zone = _15;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _16 = (int) i;
  netif->ip6_addr[_16].type = 6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _17 = (int) i;
  _18 = netif->ip6_addr[_17].u_addr.ip6.addr[0];
  _19 = _18 & 49407;
  if (_19 == 33022)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _20 = netif->num;
  iftmp.18 = _20 + 1;
  goto <bb 15>; [INV]

  <bb 14> :
  iftmp.18 = 0;

  <bb 15> :
  _21 = (int) i;
  netif->ip6_addr[_21].u_addr.ip6.zone = iftmp.18;
  # DEBUG BEGIN_STMT
  netif_ip6_addr_set_state (netif, i, 8);
  # DEBUG BEGIN_STMT
  if (chosen_idx != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  *chosen_idx = i;

  <bb 17> :
  # DEBUG BEGIN_STMT
  D.8325 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 23>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  i.19_22 = i;
  i.20_23 = (unsigned char) i.19_22;
  _24 = i.20_23 + 1;
  i = (s8_t) _24;

  <bb 19> :
  # DEBUG BEGIN_STMT
  if (i <= 2)
    goto <bb 11>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  if (chosen_idx != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  # DEBUG BEGIN_STMT
  *chosen_idx = -1;

  <bb 22> :
  # DEBUG BEGIN_STMT
  D.8325 = -6;

  <bb 23> :
  return D.8325;

}


netif_create_ip6_linklocal_address (struct netif * netif, u8_t from_mac_48bit)
{
  u8_t addr_index;
  u8_t i;
  u8_t iftmp.17;
  long unsigned int D.8311;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->ip6_addr[0].u_addr.ip6.addr[0] = 33022;
  # DEBUG BEGIN_STMT
  netif->ip6_addr[0].u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  if (from_mac_48bit != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _1 = netif->hwaddr[0];
  _2 = _1 ^ 2;
  _3 = (long unsigned int) _2;
  _4 = _3 << 24;
  _5 = netif->hwaddr[1];
  _6 = (long unsigned int) _5;
  _7 = _6 << 16;
  _8 = _4 | _7;
  _9 = netif->hwaddr[2];
  _10 = (long unsigned int) _9;
  _11 = _10 << 8;
  _12 = _8 | _11;
  _13 = _12 | 255;
  _14 = lwip_htonl (_13);
  netif->ip6_addr[0].u_addr.ip6.addr[2] = _14;
  # DEBUG BEGIN_STMT
  _15 = netif->hwaddr[3];
  _16 = (long unsigned int) _15;
  _17 = _16 << 16;
  _18 = netif->hwaddr[4];
  _19 = (long unsigned int) _18;
  _20 = _19 << 8;
  _21 = _17 | _20;
  _22 = netif->hwaddr[5];
  _23 = (long unsigned int) _22;
  _24 = _21 | _23;
  _25 = _24 | 4261412864;
  _26 = lwip_htonl (_25);
  netif->ip6_addr[0].u_addr.ip6.addr[3] = _26;
  goto <bb 12>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  netif->ip6_addr[0].u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif->ip6_addr[0].u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  addr_index = 3;
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 10>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (i == 4)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  addr_index.15_27 = addr_index;
  addr_index = addr_index.15_27 + 255;

  <bb 9> :
  # DEBUG BEGIN_STMT
  _28 = netif->hwaddr_len;
  _29 = (int) _28;
  _30 = (int) i;
  _31 = _29 - _30;
  _32 = _31 + -1;
  _33 = netif->hwaddr[_32];
  _34 = (long unsigned int) _33;
  _35 = (int) i;
  _36 = _35 & 3;
  _37 = _36 * 8;
  _38 = _34 << _37;
  D.8311 = lwip_htonl (_38);
  _39 = (int) addr_index;
  _40 = netif->ip6_addr[0].u_addr.ip6.addr[_39];
  _41 = (int) addr_index;
  _42 = D.8311 | _40;
  netif->ip6_addr[0].u_addr.ip6.addr[_41] = _42;
  # DEBUG BEGIN_STMT
  i.16_43 = i;
  i = i.16_43 + 1;

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (i <= 7)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _44 = netif->hwaddr_len;
  if (i < _44)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  _45 = netif->ip6_addr[0].u_addr.ip6.addr[0];
  _46 = _45 & 49407;
  if (_46 == 33022)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _47 = netif->num;
  iftmp.17 = _47 + 1;
  goto <bb 15>; [INV]

  <bb 14> :
  iftmp.17 = 0;

  <bb 15> :
  netif->ip6_addr[0].u_addr.ip6.zone = iftmp.17;
  # DEBUG BEGIN_STMT
  netif_ip6_addr_set_state (netif, 0, 8);
  return;

}


netif_get_ip6_addr_match (struct netif * netif, const struct ip6_addr_t * ip6addr)
{
  s8_t i;
  s8_t D.8292;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ip6addr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = ip6addr->zone;
  if (_1 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _2 = ip6addr->zone;
  _3 = netif->num;
  _4 = _3 + 1;
  if (_2 != _4)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  D.8292 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 17>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  _5 = (int) i;
  _6 = netif->ip6_addr_state[_5];
  if (_6 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 11> :
  _7 = (int) i;
  _8 = &netif->ip6_addr[_7].u_addr.ip6;
  _9 = MEM[(const struct ip6_addr_t *)_8].addr[0];
  _10 = ip6addr->addr[0];
  if (_9 == _10)
    goto <bb 12>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 12> :
  _11 = (int) i;
  _12 = &netif->ip6_addr[_11].u_addr.ip6;
  _13 = MEM[(const struct ip6_addr_t *)_12].addr[1];
  _14 = ip6addr->addr[1];
  if (_13 == _14)
    goto <bb 13>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 13> :
  _15 = (int) i;
  _16 = &netif->ip6_addr[_15].u_addr.ip6;
  _17 = MEM[(const struct ip6_addr_t *)_16].addr[2];
  _18 = ip6addr->addr[2];
  if (_17 == _18)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  _19 = (int) i;
  _20 = &netif->ip6_addr[_19].u_addr.ip6;
  _21 = MEM[(const struct ip6_addr_t *)_20].addr[3];
  _22 = ip6addr->addr[3];
  if (_21 == _22)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  D.8292 = i;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  i.13_23 = i;
  i.14_24 = (unsigned char) i.13_23;
  _25 = i.14_24 + 1;
  i = (s8_t) _25;

  <bb 17> :
  # DEBUG BEGIN_STMT
  if (i <= 2)
    goto <bb 10>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  D.8292 = -1;

  <bb 19> :
  return D.8292;

}


netif_ip6_addr_set_state (struct netif * netif, s8_t addr_idx, u8_t state)
{
  u8_t new_valid;
  u8_t old_valid;
  u8_t old_state;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (addr_idx > 2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) addr_idx;
  old_state = netif->ip6_addr_state[_1];
  # DEBUG BEGIN_STMT
  if (old_state != state)
    goto <bb 7>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  old_valid = old_state & 16;
  # DEBUG BEGIN_STMT
  new_valid = state & 16;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = netif->flags;
  _3 = (unsigned int) _2;
  _4 = _3 & 64;
  if (_4 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  nd6_adjust_mld_membership (netif, addr_idx, state);

  <bb 9> :
  # DEBUG BEGIN_STMT
  if (old_valid != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  if (new_valid == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _5 = (int) addr_idx;
  _6 = &netif->ip6_addr[_5];
  netif_do_ip_addr_changed (_6, 0B);

  <bb 12> :
  # DEBUG BEGIN_STMT
  _7 = (int) addr_idx;
  netif->ip6_addr_state[_7] = state;
  # DEBUG BEGIN_STMT
  if (old_valid == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  if (new_valid != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif, 2);

  <bb 15> :
  # DEBUG BEGIN_STMT
  _8 = old_state ^ state;
  _9 = (int) _8;
  _10 = _9 & -8;

  <bb 16> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  return;

}


netif_ip6_addr_set_parts (struct netif * netif, s8_t addr_idx, u32_t i0, u32_t i1, u32_t i2, u32_t i3)
{
  struct ip_addr_t new_ipaddr;
  struct ip_addr_t old_addr;
  u8_t iftmp.12;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (addr_idx > 2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = (int) addr_idx;
  _2 = &netif->ip6_addr[_1].u_addr.ip6;
  _3 = MEM[(const struct ip6_addr_t *)_2].addr[0];
  old_addr.u_addr.ip6.addr[0] = _3;
  # DEBUG BEGIN_STMT
  _4 = (int) addr_idx;
  _5 = &netif->ip6_addr[_4].u_addr.ip6;
  _6 = MEM[(const struct ip6_addr_t *)_5].addr[1];
  old_addr.u_addr.ip6.addr[1] = _6;
  # DEBUG BEGIN_STMT
  _7 = (int) addr_idx;
  _8 = &netif->ip6_addr[_7].u_addr.ip6;
  _9 = MEM[(const struct ip6_addr_t *)_8].addr[2];
  old_addr.u_addr.ip6.addr[2] = _9;
  # DEBUG BEGIN_STMT
  _10 = (int) addr_idx;
  _11 = &netif->ip6_addr[_10].u_addr.ip6;
  _12 = MEM[(const struct ip6_addr_t *)_11].addr[3];
  old_addr.u_addr.ip6.addr[3] = _12;
  # DEBUG BEGIN_STMT
  _13 = (int) addr_idx;
  _14 = &netif->ip6_addr[_13].u_addr.ip6;
  _15 = MEM[(const struct ip6_addr_t *)_14].zone;
  old_addr.u_addr.ip6.zone = _15;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  old_addr.type = 6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _16 = old_addr.u_addr.ip6.addr[0];
  if (i0 != _16)
    goto <bb 10>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _17 = old_addr.u_addr.ip6.addr[1];
  if (i1 != _17)
    goto <bb 10>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _18 = old_addr.u_addr.ip6.addr[2];
  if (i2 != _18)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _19 = old_addr.u_addr.ip6.addr[3];
  if (i3 != _19)
    goto <bb 10>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.addr[0] = i0;
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.addr[1] = i1;
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.addr[2] = i2;
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.addr[3] = i3;
  # DEBUG BEGIN_STMT
  new_ipaddr.u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_ipaddr.type = 6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _20 = new_ipaddr.u_addr.ip6.addr[0];
  _21 = _20 & 49407;
  if (_21 == 33022)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _22 = netif->num;
  iftmp.12 = _22 + 1;
  goto <bb 13>; [INV]

  <bb 12> :
  iftmp.12 = 0;

  <bb 13> :
  new_ipaddr.u_addr.ip6.zone = iftmp.12;
  # DEBUG BEGIN_STMT
  _23 = (int) addr_idx;
  _24 = netif->ip6_addr_state[_23];
  _25 = (int) _24;
  _26 = _25 & 16;
  if (_26 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  _27 = (int) addr_idx;
  _28 = &netif->ip6_addr[_27];
  netif_do_ip_addr_changed (_28, &new_ipaddr);

  <bb 15> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _29 = (int) addr_idx;
  _30 = new_ipaddr.type;
  netif->ip6_addr[_29].type = _30;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _31 = new_ipaddr.type;
  if (_31 == 6)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _32 = (int) addr_idx;
  _33 = new_ipaddr.u_addr.ip6.addr[0];
  netif->ip6_addr[_32].u_addr.ip6.addr[0] = _33;
  # DEBUG BEGIN_STMT
  _34 = (int) addr_idx;
  _35 = new_ipaddr.u_addr.ip6.addr[1];
  netif->ip6_addr[_34].u_addr.ip6.addr[1] = _35;
  # DEBUG BEGIN_STMT
  _36 = (int) addr_idx;
  _37 = new_ipaddr.u_addr.ip6.addr[2];
  netif->ip6_addr[_36].u_addr.ip6.addr[2] = _37;
  # DEBUG BEGIN_STMT
  _38 = (int) addr_idx;
  _39 = new_ipaddr.u_addr.ip6.addr[3];
  netif->ip6_addr[_38].u_addr.ip6.addr[3] = _39;
  # DEBUG BEGIN_STMT
  _40 = (int) addr_idx;
  _41 = new_ipaddr.u_addr.ip6.zone;
  netif->ip6_addr[_40].u_addr.ip6.zone = _41;
  # DEBUG BEGIN_STMT
  goto <bb 18>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  _42 = (int) addr_idx;
  _43 = new_ipaddr.u_addr.ip4.addr;
  netif->ip6_addr[_42].u_addr.ip4.addr = _43;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _44 = (int) addr_idx;
  netif->ip6_addr[_44].u_addr.ip6.addr[3] = 0;
  _45 = (int) addr_idx;
  _46 = netif->ip6_addr[_44].u_addr.ip6.addr[3];
  netif->ip6_addr[_45].u_addr.ip6.addr[2] = _46;
  _47 = (int) addr_idx;
  _48 = netif->ip6_addr[_45].u_addr.ip6.addr[2];
  netif->ip6_addr[_47].u_addr.ip6.addr[1] = _48;
  # DEBUG BEGIN_STMT
  _49 = (int) addr_idx;
  netif->ip6_addr[_49].u_addr.ip6.zone = 0;

  <bb 18> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _50 = (int) addr_idx;
  _51 = netif->ip6_addr_state[_50];
  _52 = (int) _51;
  _53 = _52 & 16;
  if (_53 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif, 2);

  <bb 20> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  old_addr = {CLOBBER};
  new_ipaddr = {CLOBBER};
  return;

}


netif_ip6_addr_set (struct netif * netif, s8_t addr_idx, const struct ip6_addr_t * addr6)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (addr6 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = addr6->addr[0];
  _2 = addr6->addr[1];
  _3 = addr6->addr[2];
  _4 = addr6->addr[3];
  netif_ip6_addr_set_parts (netif, addr_idx, _1, _2, _3, _4);
  return;

}


netif_alloc_client_data_id ()
{
  u8_t result;
  u8_t D.8240;

  <bb 2> :
  # DEBUG BEGIN_STMT
  result = netif_client_id;
  # DEBUG BEGIN_STMT
  netif_client_id.10_1 = netif_client_id;
  netif_client_id.11_2 = netif_client_id.10_1;
  _3 = netif_client_id.11_2 + 1;
  netif_client_id = _3;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (result != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8240 = result + 2;
  return D.8240;

}


netif_set_link_down (struct netif * netif)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 4;
  if (_3 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _4 = netif->flags;
  _5 = _4 & 251;
  netif->flags = _5;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _6 = netif->mtu;
  netif->mtu6 = _6;

  <bb 6> :
  # DEBUG BEGIN_STMT
  return;

}


netif_set_link_up (struct netif * netif)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 4;
  if (_3 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _4 = netif->flags;
  _5 = _4 | 4;
  netif->flags = _5;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif, 3);
  # DEBUG BEGIN_STMT
  nd6_restart_netif (netif);

  <bb 6> :
  # DEBUG BEGIN_STMT
  return;

}


netif_set_down (struct netif * netif)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 1;
  if (_3 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _4 = netif->flags;
  _5 = _4 & 254;
  netif->flags = _5;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _6 = sys_now ();
  _7 = _6 / 10;
  netif->ts = _7;
  # DEBUG BEGIN_STMT
  _8 = netif->flags;
  _9 = (unsigned int) _8;
  _10 = _9 & 8;
  if (_10 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  etharp_cleanup_netif (netif);

  <bb 7> :
  # DEBUG BEGIN_STMT
  nd6_cleanup_netif (netif);

  <bb 8> :
  # DEBUG BEGIN_STMT
  return;

}


netif_issue_reports (struct netif * netif, u8_t report_type)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 5;
  if (_3 != 5)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 14>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _4 = (int) report_type;
  _5 = _4 & 1;
  if (_5 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 7> :
  _6 = &netif->ip_addr.u_addr.ip4;
  _7 = MEM[(const struct ip4_addr_t *)_6].addr;
  if (_7 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _8 = netif->flags;
  _9 = (unsigned int) _8;
  _10 = _9 & 8;
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _11 = &netif->ip_addr.u_addr.ip4;
  etharp_request (netif, _11);

  <bb 10> :
  # DEBUG BEGIN_STMT
  _12 = netif->flags;
  _13 = (unsigned int) _12;
  _14 = _13 & 32;
  if (_14 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  igmp_report_groups (netif);

  <bb 12> :
  # DEBUG BEGIN_STMT
  _15 = (int) report_type;
  _16 = _15 & 2;
  if (_16 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  mld6_report_groups (netif);

  <bb 14> :
  return;

}


netif_set_up (struct netif * netif)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 1;
  if (_3 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _4 = netif->flags;
  _5 = _4 | 1;
  netif->flags = _5;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _6 = sys_now ();
  _7 = _6 / 10;
  netif->ts = _7;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif, 3);
  # DEBUG BEGIN_STMT
  nd6_restart_netif (netif);

  <bb 6> :
  return;

}


netif_set_default (struct netif * netif)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_default = netif;
  # DEBUG BEGIN_STMT
  return;

}


netif_remove (struct netif * netif)
{
  struct netif * tmp_netif;
  int i;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 26>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = &netif->ip_addr.u_addr.ip4;
  _2 = MEM[(const struct ip4_addr_t *)_1].addr;
  if (_2 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _3 = &netif->ip_addr;
  netif_do_ip_addr_changed (_3, 0B);

  <bb 6> :
  # DEBUG BEGIN_STMT
  _4 = netif->flags;
  _5 = (unsigned int) _4;
  _6 = _5 & 32;
  if (_6 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  igmp_stop (netif);

  <bb 8> :
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 12>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _7 = netif->ip6_addr_state[i];
  _8 = (int) _7;
  _9 = _8 & 16;
  if (_9 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  _10 = &netif->ip6_addr[i];
  netif_do_ip_addr_changed (_10, 0B);

  <bb 11> :
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 12> :
  # DEBUG BEGIN_STMT
  if (i <= 2)
    goto <bb 9>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  mld6_stop (netif);
  # DEBUG BEGIN_STMT
  _11 = netif->flags;
  _12 = (_Bool) _11;
  if (_12 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  netif_set_down (netif);

  <bb 15> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_default.8_13 = netif_default;
  if (netif == netif_default.8_13)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  netif_set_default (0B);

  <bb 17> :
  # DEBUG BEGIN_STMT
  netif_list.9_14 = netif_list;
  if (netif == netif_list.9_14)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  _15 = netif->next;
  netif_list = _15;
  goto <bb 26>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  tmp_netif = netif_list;
  goto <bb 23>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  _16 = tmp_netif->next;
  if (netif == _16)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  # DEBUG BEGIN_STMT
  _17 = netif->next;
  tmp_netif->next = _17;
  # DEBUG BEGIN_STMT
  goto <bb 24>; [INV]

  <bb 22> :
  # DEBUG BEGIN_STMT
  tmp_netif = tmp_netif->next;

  <bb 23> :
  # DEBUG BEGIN_STMT
  if (tmp_netif != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  # DEBUG BEGIN_STMT
  if (tmp_netif == 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.

  <bb 26> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  return;

}


netif_set_addr (struct netif * netif, const struct ip4_addr_t * ipaddr, const struct ip4_addr_t * netmask, const struct ip4_addr_t * gw)
{
  int remove;
  struct ip_addr_t old_addr;
  struct ip_addr_t * old_gw;
  struct ip_addr_t * old_nm;
  int iftmp.7;

  <bb 2> :
  # DEBUG BEGIN_STMT
  old_nm = 0B;
  # DEBUG BEGIN_STMT
  old_gw = 0B;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  ipaddr = &ip_addr_any.u_addr.ip4;

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (netmask == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  netmask = &ip_addr_any.u_addr.ip4;

  <bb 6> :
  # DEBUG BEGIN_STMT
  if (gw == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  gw = &ip_addr_any.u_addr.ip4;

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (ipaddr == 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _1 = ipaddr->addr;
  if (_1 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  iftmp.7 = 1;
  goto <bb 12>; [INV]

  <bb 11> :
  iftmp.7 = 0;

  <bb 12> :
  remove = iftmp.7;
  # DEBUG BEGIN_STMT
  if (remove != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  _2 = netif_do_set_ipaddr (netif, ipaddr, &old_addr);

  <bb 14> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _3 = netif_do_set_netmask (netif, netmask, old_nm);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _4 = netif_do_set_gw (netif, gw, old_gw);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (remove == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  _5 = netif_do_set_ipaddr (netif, ipaddr, &old_addr);

  <bb 16> :
  # DEBUG BEGIN_STMT
  old_addr = {CLOBBER};
  return;

}


netif_set_gw (struct netif * netif, const struct ip4_addr_t * gw)
{
  struct ip_addr_t * old_gw;

  <bb 2> :
  # DEBUG BEGIN_STMT
  old_gw = 0B;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (gw == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  gw = &ip_addr_any.u_addr.ip4;

  <bb 6> :
  # DEBUG BEGIN_STMT
  _1 = netif_do_set_gw (netif, gw, old_gw);

  <bb 7> :
  # DEBUG BEGIN_STMT
  return;

}


netif_do_set_gw (struct netif * netif, const struct ip4_addr_t * gw, struct ip_addr_t * old_gw)
{
  int D.8168;
  const long unsigned int iftmp.6;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = gw->addr;
  _2 = &netif->gw.u_addr.ip4;
  _3 = MEM[(const struct ip4_addr_t *)_2].addr;
  if (_1 != _3)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (gw != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.6 = gw->addr;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.6 = 0;

  <bb 6> :
  netif->gw.u_addr.ip4.addr = iftmp.6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->gw.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8168 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  D.8168 = 0;

  <bb 8> :
  return D.8168;

}


netif_set_netmask (struct netif * netif, const struct ip4_addr_t * netmask)
{
  struct ip_addr_t * old_nm;

  <bb 2> :
  # DEBUG BEGIN_STMT
  old_nm = 0B;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netmask == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  netmask = &ip_addr_any.u_addr.ip4;

  <bb 6> :
  # DEBUG BEGIN_STMT
  _1 = netif_do_set_netmask (netif, netmask, old_nm);

  <bb 7> :
  # DEBUG BEGIN_STMT
  return;

}


netif_do_set_netmask (struct netif * netif, const struct ip4_addr_t * netmask, struct ip_addr_t * old_nm)
{
  int D.8153;
  const long unsigned int iftmp.5;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = netmask->addr;
  _2 = &netif->netmask.u_addr.ip4;
  _3 = MEM[(const struct ip4_addr_t *)_2].addr;
  if (_1 != _3)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netmask != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  iftmp.5 = netmask->addr;
  goto <bb 6>; [INV]

  <bb 5> :
  iftmp.5 = 0;

  <bb 6> :
  netif->netmask.u_addr.ip4.addr = iftmp.5;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->netmask.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8153 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  D.8153 = 0;

  <bb 8> :
  return D.8153;

}


netif_set_ipaddr (struct netif * netif, const struct ip4_addr_t * ipaddr)
{
  struct ip_addr_t old_addr;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  // predicted unlikely by early return (on trees) predictor.
  old_addr = {CLOBBER};
  goto <bb 7>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  ipaddr = &ip_addr_any.u_addr.ip4;

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif_do_set_ipaddr (netif, ipaddr, &old_addr);
  # DEBUG BEGIN_STMT
  old_addr = {CLOBBER};

  <bb 7> :
  return;

}


netif_do_set_ipaddr (struct netif * netif, const struct ip4_addr_t * ipaddr, struct ip_addr_t * old_addr)
{
  struct ip_addr_t new_addr;
  int D.8122;
  const long unsigned int iftmp.4;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (old_addr == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = ipaddr->addr;
  _2 = &netif->ip_addr.u_addr.ip4;
  _3 = MEM[(const struct ip4_addr_t *)_2].addr;
  if (_1 != _3)
    goto <bb 7>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_addr.u_addr.ip4 = *ipaddr;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  new_addr.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _4 = &netif->ip_addr;
  _5 = MEM[(const struct ip_addr_t *)_4].type;
  old_addr->type = _5;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _6 = &netif->ip_addr;
  _7 = MEM[(const struct ip_addr_t *)_6].type;
  if (_7 == 6)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _8 = &netif->ip_addr;
  _9 = MEM[(const struct ip_addr_t *)_8].u_addr.ip6.addr[0];
  old_addr->u_addr.ip6.addr[0] = _9;
  # DEBUG BEGIN_STMT
  _10 = &netif->ip_addr;
  _11 = MEM[(const struct ip_addr_t *)_10].u_addr.ip6.addr[1];
  old_addr->u_addr.ip6.addr[1] = _11;
  # DEBUG BEGIN_STMT
  _12 = &netif->ip_addr;
  _13 = MEM[(const struct ip_addr_t *)_12].u_addr.ip6.addr[2];
  old_addr->u_addr.ip6.addr[2] = _13;
  # DEBUG BEGIN_STMT
  _14 = &netif->ip_addr;
  _15 = MEM[(const struct ip_addr_t *)_14].u_addr.ip6.addr[3];
  old_addr->u_addr.ip6.addr[3] = _15;
  # DEBUG BEGIN_STMT
  _16 = &netif->ip_addr;
  _17 = MEM[(const struct ip_addr_t *)_16].u_addr.ip6.zone;
  old_addr->u_addr.ip6.zone = _17;
  # DEBUG BEGIN_STMT
  goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _18 = &netif->ip_addr;
  _19 = MEM[(const struct ip_addr_t *)_18].u_addr.ip4.addr;
  old_addr->u_addr.ip4.addr = _19;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  old_addr->u_addr.ip6.addr[3] = 0;
  _20 = old_addr->u_addr.ip6.addr[3];
  old_addr->u_addr.ip6.addr[2] = _20;
  _21 = old_addr->u_addr.ip6.addr[2];
  old_addr->u_addr.ip6.addr[1] = _21;
  # DEBUG BEGIN_STMT
  old_addr->u_addr.ip6.zone = 0;

  <bb 10> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_do_ip_addr_changed (old_addr, &new_addr);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  iftmp.4 = ipaddr->addr;
  goto <bb 13>; [INV]

  <bb 12> :
  iftmp.4 = 0;

  <bb 13> :
  netif->ip_addr.u_addr.ip4.addr = iftmp.4;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->ip_addr.type = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_issue_reports (netif, 1);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8122 = 1;
  // predicted unlikely by early return (on trees) predictor.
  new_addr = {CLOBBER};
  goto <bb 15>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  D.8122 = 0;

  <bb 15> :
  return D.8122;

}


netif_do_ip_addr_changed (const struct ip_addr_t * old_addr, const struct ip_addr_t * new_addr)
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  tcp_netif_ip_addr_changed (old_addr, new_addr);
  # DEBUG BEGIN_STMT
  udp_netif_ip_addr_changed (old_addr, new_addr);
  # DEBUG BEGIN_STMT
  raw_netif_ip_addr_changed (old_addr, new_addr);
  return;

}


netif_add (struct netif * netif, const struct ip4_addr_t * ipaddr, const struct ip4_addr_t * netmask, const struct ip4_addr_t * gw, void * state, err_t (*netif_init_fn) (struct netif *) init, err_t (*netif_input_fn) (struct pbuf *, struct netif *) input)
{
  int num_netifs;
  struct netif * netif2;
  s8_t i;
  struct netif * D.8063;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  D.8063 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 44>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (init == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  D.8063 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 44>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (ipaddr == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  ipaddr = &ip_addr_any.u_addr.ip4;

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (netmask == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  netmask = &ip_addr_any.u_addr.ip4;

  <bb 10> :
  # DEBUG BEGIN_STMT
  if (gw == 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  gw = &ip_addr_any.u_addr.ip4;

  <bb 12> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->ip_addr.u_addr.ip6.addr[0] = 0;
  # DEBUG BEGIN_STMT
  netif->ip_addr.u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  netif->ip_addr.u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif->ip_addr.u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  netif->ip_addr.u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = &netif->ip_addr;
  if (_1 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->ip_addr.type = 0;

  <bb 14> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->netmask.u_addr.ip6.addr[0] = 0;
  # DEBUG BEGIN_STMT
  netif->netmask.u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  netif->netmask.u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif->netmask.u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  netif->netmask.u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = &netif->netmask;
  if (_2 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->netmask.type = 0;

  <bb 16> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->gw.u_addr.ip6.addr[0] = 0;
  # DEBUG BEGIN_STMT
  netif->gw.u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  netif->gw.u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  netif->gw.u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  netif->gw.u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _3 = &netif->gw;
  if (_3 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->gw.type = 0;

  <bb 18> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->output = netif_null_output_ip4;
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 22>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _4 = (int) i;
  netif->ip6_addr[_4].u_addr.ip6.addr[0] = 0;
  # DEBUG BEGIN_STMT
  _5 = (int) i;
  netif->ip6_addr[_5].u_addr.ip6.addr[1] = 0;
  # DEBUG BEGIN_STMT
  _6 = (int) i;
  netif->ip6_addr[_6].u_addr.ip6.addr[2] = 0;
  # DEBUG BEGIN_STMT
  _7 = (int) i;
  netif->ip6_addr[_7].u_addr.ip6.addr[3] = 0;
  # DEBUG BEGIN_STMT
  _8 = (int) i;
  netif->ip6_addr[_8].u_addr.ip6.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _9 = (int) i;
  _10 = &netif->ip6_addr[_9];
  if (_10 != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _11 = (int) i;
  netif->ip6_addr[_11].type = 6;

  <bb 21> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _12 = (int) i;
  netif->ip6_addr_state[_12] = 0;
  # DEBUG BEGIN_STMT
  _13 = (int) i;
  netif->ip6_addr_valid_life[_13] = 0;
  # DEBUG BEGIN_STMT
  _14 = (int) i;
  netif->ip6_addr_pref_life[_14] = 0;
  # DEBUG BEGIN_STMT
  i.0_15 = i;
  i.1_16 = (unsigned char) i.0_15;
  _17 = i.1_16 + 1;
  i = (s8_t) _17;

  <bb 22> :
  # DEBUG BEGIN_STMT
  if (i <= 2)
    goto <bb 19>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  # DEBUG BEGIN_STMT
  netif->output_ip6 = netif_null_output_ip6;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->mtu = 0;
  # DEBUG BEGIN_STMT
  netif->flags = 0;
  # DEBUG BEGIN_STMT
  _18 = &netif->client_data;
  memset (_18, 0, 12);
  # DEBUG BEGIN_STMT
  netif->ip6_autoconfig_enabled = 0;
  # DEBUG BEGIN_STMT
  nd6_restart_netif (netif);
  # DEBUG BEGIN_STMT
  netif->igmp_mac_filter = 0B;
  # DEBUG BEGIN_STMT
  netif->mld_mac_filter = 0B;
  # DEBUG BEGIN_STMT
  netif->state = state;
  # DEBUG BEGIN_STMT
  netif_num.2_19 = netif_num;
  netif->num = netif_num.2_19;
  # DEBUG BEGIN_STMT
  netif->input = input;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif_set_addr (netif, ipaddr, netmask, gw);
  # DEBUG BEGIN_STMT
  _20 = init (netif);
  if (_20 != 0)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  # DEBUG BEGIN_STMT
  D.8063 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 44>; [INV]

  <bb 25> :
  # DEBUG BEGIN_STMT
  _21 = netif->mtu;
  netif->mtu6 = _21;

  <bb 26> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _22 = netif->num;
  if (_22 == 255)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  # DEBUG BEGIN_STMT
  netif->num = 0;

  <bb 28> :
  # DEBUG BEGIN_STMT
  num_netifs = 0;
  # DEBUG BEGIN_STMT
  netif2 = netif_list;
  goto <bb 36>; [INV]

  <bb 29> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif2 == netif)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 30>; [INV]

  <bb 31> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  num_netifs = num_netifs + 1;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (num_netifs > 255)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 32>; [INV]

  <bb 33> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _23 = netif2->num;
  _24 = netif->num;
  if (_23 == _24)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  # DEBUG BEGIN_STMT
  _25 = netif->num;
  _26 = _25;
  _27 = _26 + 1;
  netif->num = _27;
  # DEBUG BEGIN_STMT
  goto <bb 37>; [INV]

  <bb 35> :
  # DEBUG BEGIN_STMT
  netif2 = netif2->next;

  <bb 36> :
  # DEBUG BEGIN_STMT
  if (netif2 != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 37> :
  # DEBUG BEGIN_STMT
  if (netif2 != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 38> :
  # DEBUG BEGIN_STMT
  _28 = netif->num;
  if (_28 == 254)
    goto <bb 39>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 39> :
  # DEBUG BEGIN_STMT
  netif_num = 0;
  goto <bb 41>; [INV]

  <bb 40> :
  # DEBUG BEGIN_STMT
  _29 = netif->num;
  _30 = _29 + 1;
  netif_num = _30;

  <bb 41> :
  # DEBUG BEGIN_STMT
  netif_list.3_31 = netif_list;
  netif->next = netif_list.3_31;
  # DEBUG BEGIN_STMT
  netif_list = netif;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _32 = netif->flags;
  _33 = (unsigned int) _32;
  _34 = _33 & 32;
  if (_34 != 0)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  # DEBUG BEGIN_STMT
  igmp_start (netif);

  <bb 43> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.8063 = netif;

  <bb 44> :
  return D.8063;

}


netif_add_noaddr (struct netif * netif, void * state, err_t (*netif_init_fn) (struct netif *) init, err_t (*netif_input_fn) (struct pbuf *, struct netif *) input)
{
  struct netif * D.8059;

  <bb 2> :
  # DEBUG BEGIN_STMT
  D.8059 = netif_add (netif, 0B, 0B, 0B, state, init, input);
  return D.8059;

}


netif_input (struct pbuf * p, struct netif * inp)
{
  err_t D.8057;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (p == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (inp == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = inp->flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 24;
  if (_3 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  D.8057 = ethernet_input (p, inp);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  D.8057 = ip_input (p, inp);
  // predicted unlikely by early return (on trees) predictor.

  <bb 9> :
  return D.8057;

}


netif_init ()
{
  <bb 2> :
  # DEBUG BEGIN_STMT
  return;

}



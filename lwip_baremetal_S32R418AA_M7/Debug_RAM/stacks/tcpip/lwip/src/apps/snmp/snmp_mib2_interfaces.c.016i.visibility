
Marking local functions:


Marking externally visible functions:


Marking externally visible variables: snmp_mib2_interface_root


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

snmp_scalar_get_next_instance/28 (snmp_scalar_get_next_instance) @061a2e00
  Type: function
  Visibility: external public
  Address is taken.
  References: 
  Referring: interfaces_Number/12 (addr)
  Availability: not_available
  Function flags: optimize_size
  Called by: 
  Calls: 
snmp_scalar_get_instance/27 (snmp_scalar_get_instance) @061a2d20
  Type: function
  Visibility: external public
  Address is taken.
  References: 
  Referring: interfaces_Number/12 (addr)
  Availability: not_available
  Function flags: optimize_size
  Called by: 
  Calls: 
snmp_oid_in_range/26 (snmp_oid_in_range) @061a2c40
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: interfaces_Table_get_cell_instance/9 
  Calls: 
snmp_oid_assign/25 (snmp_oid_assign) @061a2a80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: interfaces_Table_get_next_cell_instance/10 
  Calls: 
snmp_next_oid_check/24 (snmp_next_oid_check) @061a29a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: interfaces_Table_get_next_cell_instance/10 
  Calls: 
netif_list/23 (netif_list) @061c4798
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: interfaces_Table_get_next_cell_instance/10 (read)interfaces_Table_get_cell_instance/9 (read)interfaces_get_value/1 (read)
  Availability: not_available
  Varpool flags:
snmp_next_oid_init/22 (snmp_next_oid_init) @061a28c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: interfaces_Table_get_next_cell_instance/10 
  Calls: 
snmp_zero_dot_zero/21 (snmp_zero_dot_zero) @061c43f0
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: interfaces_Table_get_value/11 (read)interfaces_Table_get_value/11 (read)
  Availability: not_available
  Varpool flags: read-only
memcpy/20 (memcpy) @061a2700
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: interfaces_Table_get_value/11 interfaces_Table_get_value/11 interfaces_Table_get_value/11 
  Calls: 
netif_to_num/19 (netif_to_num) @061a2620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: interfaces_Table_get_cell_instance/9 interfaces_Table_get_next_cell_instance/10 interfaces_Table_get_value/11 
  Calls: 
snmp_table_get_next_instance/18 (snmp_table_get_next_instance) @0619fee0
  Type: function
  Visibility: external public
  Address is taken.
  References: 
  Referring: interfaces_Table/14 (addr)
  Availability: not_available
  Function flags: optimize_size
  Called by: 
  Calls: 
snmp_table_get_instance/17 (snmp_table_get_instance) @0619fe00
  Type: function
  Visibility: external public
  Address is taken.
  References: 
  Referring: interfaces_Table/14 (addr)
  Availability: not_available
  Function flags: optimize_size
  Called by: 
  Calls: 
snmp_mib2_interface_root/16 (snmp_mib2_interface_root) @06173630
  Type: variable definition analyzed
  Visibility: externally_visible public
  References: interface_nodes/15 (addr)
  Referring: 
  Availability: available
  Varpool flags: initialized read-only const-value-known
interface_nodes/15 (interface_nodes) @061735a0
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: interfaces_Number/12 (addr)interfaces_Table/14 (addr)
  Referring: snmp_mib2_interface_root/16 (addr)
  Availability: available
  Varpool flags: initialized read-only const-value-known
interfaces_Table/14 (interfaces_Table) @06173510
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: snmp_table_get_instance/17 (addr)snmp_table_get_next_instance/18 (addr)interfaces_Table_columns/13 (addr)interfaces_Table_get_cell_instance/9 (addr)interfaces_Table_get_next_cell_instance/10 (addr)interfaces_Table_get_value/11 (addr)
  Referring: interface_nodes/15 (addr)
  Availability: available
  Varpool flags: initialized read-only const-value-known
interfaces_Table_columns/13 (interfaces_Table_columns) @06173438
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: interfaces_Table/14 (addr)
  Availability: available
  Varpool flags: initialized read-only const-value-known
interfaces_Number/12 (interfaces_Number) @06173360
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: snmp_scalar_get_instance/27 (addr)snmp_scalar_get_next_instance/28 (addr)interfaces_get_value/1 (addr)
  Referring: interface_nodes/15 (addr)
  Availability: available
  Varpool flags: initialized read-only const-value-known
interfaces_Table_get_value/11 (interfaces_Table_get_value) @06171b60
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: snmp_zero_dot_zero/21 (read)snmp_zero_dot_zero/21 (read)
  Referring: interfaces_Table/14 (addr)
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: memcpy/20 memcpy/20 memcpy/20 netif_to_num/19 
interfaces_Table_get_next_cell_instance/10 (interfaces_Table_get_next_cell_instance) @06171540
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: netif_list/23 (read)
  Referring: interfaces_Table/14 (addr)
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: snmp_oid_assign/25 snmp_next_oid_check/24 netif_to_num/19 snmp_next_oid_init/22 
interfaces_Table_get_cell_instance/9 (interfaces_Table_get_cell_instance) @0616bee0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: interfaces_Table_oid_ranges/2 (addr)netif_list/23 (read)
  Referring: interfaces_Table/14 (addr)
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: netif_to_num/19 snmp_oid_in_range/26 
interfaces_Table_oid_ranges/2 (interfaces_Table_oid_ranges) @0616aab0
  Type: variable definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: interfaces_Table_get_cell_instance/9 (addr)
  Availability: available
  Varpool flags: initialized read-only const-value-known
interfaces_get_value/1 (interfaces_get_value) @0616b0e0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: netif_list/23 (read)
  Referring: interfaces_Number/12 (addr)
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
interfaces_Table_get_value (struct snmp_node_instance * instance, void * value)
{
  u16_t value_len;
  s32_t * value_s32;
  u32_t * value_u32;
  struct netif * netif;
  s16_t D.7455;

  <bb 2> :
  # DEBUG BEGIN_STMT
  netif = instance->reference.ptr;
  # DEBUG BEGIN_STMT
  value_u32 = value;
  # DEBUG BEGIN_STMT
  value_s32 = value;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = instance->instance_oid.id[1];
  switch (_1) <default: <L31> [INV], case 1: <L0> [INV], case 2: <L1> [INV], case 3: <L2> [INV], case 4: <L3> [INV], case 5: <L4> [INV], case 6: <L5> [INV], case 7: <L6> [INV], case 8: <L10> [INV], case 9: <L17> [INV], case 10: <L18> [INV], case 11: <L19> [INV], case 12: <L20> [INV], case 13: <L21> [INV], case 14: <L22> [INV], case 15: <L23> [INV], case 16: <L24> [INV], case 17: <L25> [INV], case 18: <L26> [INV], case 19: <L27> [INV], case 20: <L28> [INV], case 21: <L29> [INV], case 22: <L30> [INV]>

  <bb 3> :
<L0>:
  # DEBUG BEGIN_STMT
  _2 = netif_to_num (netif);
  _3 = (long int) _2;
  *value_s32 = _3;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 4> :
<L1>:
  # DEBUG BEGIN_STMT
  value_len = 2;
  # DEBUG BEGIN_STMT
  _4 = &netif->name;
  _5 = (unsigned int) value_len;
  memcpy (value, _4, _5);
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 5> :
<L2>:
  # DEBUG BEGIN_STMT
  _6 = netif->link_type;
  _7 = (long int) _6;
  *value_s32 = _7;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 6> :
<L3>:
  # DEBUG BEGIN_STMT
  _8 = netif->mtu;
  _9 = (long int) _8;
  *value_s32 = _9;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 7> :
<L4>:
  # DEBUG BEGIN_STMT
  _10 = netif->link_speed;
  *value_u32 = _10;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 8> :
<L5>:
  # DEBUG BEGIN_STMT
  value_len = 6;
  # DEBUG BEGIN_STMT
  _11 = &netif->hwaddr;
  _12 = (unsigned int) value_len;
  memcpy (value, _11, _12);
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 9> :
<L6>:
  # DEBUG BEGIN_STMT
  _13 = netif->flags;
  _14 = (_Bool) _13;
  if (_14 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  *value_s32 = 1;
  goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  *value_s32 = 2;

  <bb 12> :
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 13> :
<L10>:
  # DEBUG BEGIN_STMT
  _15 = netif->flags;
  _16 = (_Bool) _15;
  if (_16 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  _17 = netif->flags;
  _18 = (unsigned int) _17;
  _19 = _18 >> 2;
  _20 = (_Bool) _19;
  if (_20 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  *value_s32 = 1;
  goto <bb 18>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  *value_s32 = 7;
  goto <bb 18>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  *value_s32 = 2;

  <bb 18> :
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 19> :
<L17>:
  # DEBUG BEGIN_STMT
  _21 = netif->ts;
  *value_u32 = _21;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 20> :
<L18>:
  # DEBUG BEGIN_STMT
  _22 = netif->mib2_counters.ifinoctets;
  *value_u32 = _22;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 21> :
<L19>:
  # DEBUG BEGIN_STMT
  _23 = netif->mib2_counters.ifinucastpkts;
  *value_u32 = _23;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 22> :
<L20>:
  # DEBUG BEGIN_STMT
  _24 = netif->mib2_counters.ifinnucastpkts;
  *value_u32 = _24;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 23> :
<L21>:
  # DEBUG BEGIN_STMT
  _25 = netif->mib2_counters.ifindiscards;
  *value_u32 = _25;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 24> :
<L22>:
  # DEBUG BEGIN_STMT
  _26 = netif->mib2_counters.ifinerrors;
  *value_u32 = _26;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 25> :
<L23>:
  # DEBUG BEGIN_STMT
  _27 = netif->mib2_counters.ifinunknownprotos;
  *value_u32 = _27;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 26> :
<L24>:
  # DEBUG BEGIN_STMT
  _28 = netif->mib2_counters.ifoutoctets;
  *value_u32 = _28;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 27> :
<L25>:
  # DEBUG BEGIN_STMT
  _29 = netif->mib2_counters.ifoutucastpkts;
  *value_u32 = _29;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 28> :
<L26>:
  # DEBUG BEGIN_STMT
  _30 = netif->mib2_counters.ifoutnucastpkts;
  *value_u32 = _30;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 29> :
<L27>:
  # DEBUG BEGIN_STMT
  _31 = netif->mib2_counters.ifoutdiscards;
  *value_u32 = _31;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 30> :
<L28>:
  # DEBUG BEGIN_STMT
  _32 = netif->mib2_counters.ifouterrors;
  *value_u32 = _32;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 31> :
<L29>:
  # DEBUG BEGIN_STMT
  *value_u32 = 0;
  # DEBUG BEGIN_STMT
  value_len = 4;
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 32> :
<L30>:
  # DEBUG BEGIN_STMT
  _33 = snmp_zero_dot_zero.len;
  _34 = (short unsigned int) _33;
  value_len = _34 * 4;
  # DEBUG BEGIN_STMT
  _35 = snmp_zero_dot_zero.id;
  _36 = (unsigned int) value_len;
  memcpy (value, _35, _36);
  # DEBUG BEGIN_STMT
  goto <bb 34>; [INV]

  <bb 33> :
<L31>:
  # DEBUG BEGIN_STMT
  D.7455 = 0;
  goto <bb 35>; [INV]

  <bb 34> :
  # DEBUG BEGIN_STMT
  D.7455 = (s16_t) value_len;

  <bb 35> :
  return D.7455;

}


interfaces_Table_get_next_cell_instance (const u32_t * column, struct snmp_obj_id * row_oid, struct snmp_node_instance * cell_instance)
{
  u32_t test_oid[1];
  u32_t result_temp[1];
  struct snmp_next_oid_state state;
  struct netif * netif;
  snmp_err_t D.7459;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = &row_oid->id;
  _2 = row_oid->len;
  snmp_next_oid_init (&state, _1, _2, &result_temp, 1);
  # DEBUG BEGIN_STMT
  netif = netif_list;
  goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _3 = netif_to_num (netif);
  _4 = (long unsigned int) _3;
  test_oid[0] = _4;
  # DEBUG BEGIN_STMT
  snmp_next_oid_check (&state, &test_oid, 1, netif);
  test_oid = {CLOBBER};
  # DEBUG BEGIN_STMT
  netif = netif->next;

  <bb 4> :
  # DEBUG BEGIN_STMT
  if (netif != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _5 = state.status;
  if (_5 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _6 = state.next_oid;
  _7 = state.next_oid_len;
  snmp_oid_assign (row_oid, _6, _7);
  # DEBUG BEGIN_STMT
  _8 = state.reference;
  cell_instance->reference.ptr = _8;
  # DEBUG BEGIN_STMT
  D.7459 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  D.7459 = 241;

  <bb 8> :
  state = {CLOBBER};
  result_temp = {CLOBBER};
  return D.7459;

}


interfaces_Table_get_cell_instance (const u32_t * column, const u32_t * row_oid, u8_t row_oid_len, struct snmp_node_instance * cell_instance)
{
  struct netif * netif;
  u32_t ifIndex;
  snmp_err_t D.7464;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = snmp_oid_in_range (row_oid, row_oid_len, &interfaces_Table_oid_ranges, 1);
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  D.7464 = 241;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  ifIndex = *row_oid;
  # DEBUG BEGIN_STMT
  netif = netif_list;
  goto <bb 8>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _2 = netif_to_num (netif);
  _3 = (long unsigned int) _2;
  if (ifIndex == _3)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  cell_instance->reference.ptr = netif;
  # DEBUG BEGIN_STMT
  D.7464 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  netif = netif->next;

  <bb 8> :
  # DEBUG BEGIN_STMT
  if (netif != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  D.7464 = 241;

  <bb 10> :
  return D.7464;

}


interfaces_get_value (struct snmp_node_instance * instance, void * value)
{
  struct netif * netif;
  s32_t num_netifs;
  s32_t * sint_ptr;
  s16_t D.7470;

  <bb 2> :
  # DEBUG BEGIN_STMT
  _1 = instance->node;
  _2 = _1->oid;
  if (_2 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  sint_ptr = value;
  # DEBUG BEGIN_STMT
  num_netifs = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif = netif_list;
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  num_netifs = num_netifs + 1;
  # DEBUG BEGIN_STMT
  netif = netif->next;

  <bb 5> :
  # DEBUG BEGIN_STMT
  if (netif != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  *sint_ptr = num_netifs;
  # DEBUG BEGIN_STMT
  D.7470 = 4;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  D.7470 = 0;

  <bb 8> :
  return D.7470;

}




Marking local functions: bridgeif_send_to_ports bridgeif_send_to_port bridgeif_is_local_mac bridgeif_find_dst_ports


Marking externally visible functions: bridgeif_add_port bridgeif_init bridgeif_fdb_remove bridgeif_fdb_add


Marking externally visible variables: bridgeif_netif_client_id


Reclaiming functions:
Reclaiming variables:
Clearing address taken flags:
Symbol table:

pbuf_free/24 (pbuf_free) @06da6620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_input/9 bridgeif_input/9 bridgeif_input/9 
  Calls: 
bridgeif_fdb_update_src/23 (bridgeif_fdb_update_src) @06da6540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_input/9 
  Calls: 
bridgeif_fdb_get_dst_ports/22 (bridgeif_fdb_get_dst_ports) @06da6000
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_find_dst_ports/4 
  Calls: 
lwip_stats/21 (lwip_stats) @06da0168
  Type: variable
  Body removed by symtab_remove_unreachable_nodes
  Visibility: external public
  References: 
  Referring: bridgeif_output/8 (read)bridgeif_output/8 (write)
  Availability: not_available
  Varpool flags:
ethip6_output/20 (ethip6_output) @06d5ed20
  Type: function
  Visibility: external public
  Address is taken.
  References: 
  Referring: bridgeif_init/10 (addr)
  Availability: not_available
  Function flags: optimize_size
  Called by: 
  Calls: 
etharp_output/19 (etharp_output) @06d5ec40
  Type: function
  Visibility: external public
  Address is taken.
  References: 
  Referring: bridgeif_init/10 (addr)
  Availability: not_available
  Function flags: optimize_size
  Called by: 
  Calls: 
mem_free/18 (mem_free) @06d5eb60
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_init/10 
  Calls: 
bridgeif_fdb_init/17 (bridgeif_fdb_init) @06d5ea80
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_init/10 
  Calls: 
mem_calloc/16 (mem_calloc) @06d5e9a0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_init/10 
  Calls: 
netif_alloc_client_data_id/15 (netif_alloc_client_data_id) @06d5e8c0
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_init/10 
  Calls: 
memset/14 (memset) @06d5e620
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_fdb_remove/3 
  Calls: 
memcmp/13 (memcmp) @06d5e540
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_is_local_mac/5 bridgeif_is_local_mac/5 bridgeif_find_dst_ports/4 bridgeif_fdb_remove/3 bridgeif_fdb_remove/3 
  Calls: 
memcpy/12 (memcpy) @06d5e380
  Type: function
  Visibility: external public
  References: 
  Referring: 
  Availability: not_available
  Function flags: optimize_size
  Called by: bridgeif_init/10 bridgeif_init/10 bridgeif_fdb_add/2 
  Calls: 
bridgeif_add_port/11 (bridgeif_add_port) @06d46ee0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: bridgeif_input/9 (addr)bridgeif_netif_client_id/1 (read)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: 
bridgeif_init/10 (bridgeif_init) @06d46e00
  Type: function definition analyzed
  Visibility: externally_visible public
  References: bridgeif_netif_client_id/1 (read)bridgeif_netif_client_id/1 (write)etharp_output/19 (addr)ethip6_output/20 (addr)bridgeif_output/8 (addr)
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: memcpy/12 mem_free/18 bridgeif_fdb_init/17 memcpy/12 mem_calloc/16 netif_alloc_client_data_id/15 
   Indirect call
bridgeif_input/9 (bridgeif_input) @06d46a80
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: bridgeif_netif_client_id/1 (read)
  Referring: bridgeif_add_port/11 (addr)
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: pbuf_free/24 bridgeif_send_to_ports/7 bridgeif_find_dst_ports/4 bridgeif_is_local_mac/5 pbuf_free/24 pbuf_free/24 bridgeif_send_to_ports/7 bridgeif_find_dst_ports/4 bridgeif_fdb_update_src/23 
   Indirect call
   Indirect call
bridgeif_output/8 (bridgeif_output) @06d467e0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  Address is taken.
  References: lwip_stats/21 (read)lwip_stats/21 (write)
  Referring: bridgeif_init/10 (addr)
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: bridgeif_send_to_ports/7 bridgeif_find_dst_ports/4 
bridgeif_send_to_ports/7 (bridgeif_send_to_ports) @06d462a0
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: bridgeif_input/9 bridgeif_input/9 bridgeif_output/8 
  Calls: bridgeif_send_to_port/6 
bridgeif_send_to_port/6 (bridgeif_send_to_port) @06d46000
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: bridgeif_send_to_ports/7 
  Calls: 
   Indirect call
bridgeif_is_local_mac/5 (bridgeif_is_local_mac) @06d3be00
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: bridgeif_input/9 
  Calls: memcmp/13 memcmp/13 
bridgeif_find_dst_ports/4 (bridgeif_find_dst_ports) @06d3bb60
  Type: function definition analyzed
  Visibility: prevailing_def_ironly
  References: 
  Referring: 
  Availability: local
  Function flags: body local optimize_size
  Called by: bridgeif_input/9 bridgeif_input/9 bridgeif_output/8 
  Calls: bridgeif_fdb_get_dst_ports/22 memcmp/13 
bridgeif_fdb_remove/3 (bridgeif_fdb_remove) @06d3b8c0
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: memset/14 memcmp/13 memcmp/13 
bridgeif_fdb_add/2 (bridgeif_fdb_add) @06d3b620
  Type: function definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: 
  Availability: available
  Function flags: body optimize_size
  Called by: 
  Calls: memcpy/12 
bridgeif_netif_client_id/1 (bridgeif_netif_client_id) @06d36948
  Type: variable definition analyzed
  Visibility: externally_visible public
  References: 
  Referring: bridgeif_init/10 (read)bridgeif_init/10 (write)bridgeif_add_port/11 (read)bridgeif_input/9 (read)
  Availability: available
  Varpool flags: initialized
bridgeif_add_port (struct netif * bridgeif, struct netif * portif)
{
  struct bridgeif_port_t * port;
  struct bridgeif_private_t * br;
  err_t D.7415;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (bridgeif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = bridgeif->state;
  if (_1 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (portif == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 7>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _2 = portif->flags;
  _3 = (unsigned int) _2;
  _4 = _3 & 24;
  if (_4 != 24)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  D.7415 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  br = bridgeif->state;
  # DEBUG BEGIN_STMT
  _5 = br->num_ports;
  _6 = br->max_ports;
  if (_5 >= _6)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  D.7415 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  _7 = br->ports;
  _8 = br->num_ports;
  _9 = (unsigned int) _8;
  _10 = _9 * 12;
  port = _7 + _10;
  # DEBUG BEGIN_STMT
  port->port_netif = portif;
  # DEBUG BEGIN_STMT
  _11 = br->num_ports;
  port->port_num = _11;
  # DEBUG BEGIN_STMT
  port->bridge = br;
  # DEBUG BEGIN_STMT
  _12 = br->num_ports;
  _13 = _12;
  _14 = _13 + 1;
  br->num_ports = _14;
  # DEBUG BEGIN_STMT
  portif->input = bridgeif_input;
  # DEBUG BEGIN_STMT
  bridgeif_netif_client_id.15_15 = bridgeif_netif_client_id;
  _16 = (int) bridgeif_netif_client_id.15_15;
  portif->client_data[_16] = port;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _17 = portif->flags;
  _18 = _17 & 247;
  portif->flags = _18;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7415 = 0;

  <bb 13> :
  return D.7415;

}


bridgeif_init (struct netif * netif)
{
  struct ip6_addr_t ip6_allnodes_ll;
  mem_size_t alloc_len;
  size_t alloc_len_sizet;
  struct bridgeif_private_t * br;
  struct bridgeif_initdata_t * init_data;
  err_t D.7365;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (netif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif->input;
  if (_1 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  bridgeif_netif_client_id.10_2 = bridgeif_netif_client_id;
  if (bridgeif_netif_client_id.10_2 == 255)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _3 = netif_alloc_client_data_id ();
  bridgeif_netif_client_id = _3;

  <bb 8> :
  # DEBUG BEGIN_STMT
  init_data = netif->state;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (init_data == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 9>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _4 = init_data->max_ports;
  if (_4 > 7)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 11>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _5 = init_data->max_ports;
  _6 = (unsigned int) _5;
  _7 = _6 * 12;
  _8 = init_data->max_fdb_static_entries;
  _9 = (unsigned int) _8;
  _10 = _9 * 8;
  _11 = _7 + _10;
  alloc_len_sizet = _11 + 32;
  # DEBUG BEGIN_STMT
  alloc_len = alloc_len_sizet;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (alloc_len != alloc_len_sizet)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 13>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  br = mem_calloc (1, alloc_len);
  # DEBUG BEGIN_STMT
  if (br == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7365 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  _12 = &br->ethaddr;
  _13 = &init_data->ethaddr;
  memcpy (_12, _13, 6);
  # DEBUG BEGIN_STMT
  br->netif = netif;
  # DEBUG BEGIN_STMT
  _14 = init_data->max_ports;
  br->max_ports = _14;
  # DEBUG BEGIN_STMT
  _15 = br + 32;
  br->ports = _15;
  # DEBUG BEGIN_STMT
  _16 = init_data->max_fdb_static_entries;
  br->max_fdbs_entries = _16;
  # DEBUG BEGIN_STMT
  _17 = br + 32;
  _18 = init_data->max_ports;
  _19 = (unsigned int) _18;
  _20 = _19 * 12;
  _21 = _17 + _20;
  br->fdbs = _21;
  # DEBUG BEGIN_STMT
  _22 = init_data->max_fdb_dynamic_entries;
  br->max_fdbd_entries = _22;
  # DEBUG BEGIN_STMT
  _23 = init_data->max_fdb_dynamic_entries;
  _24 = bridgeif_fdb_init (_23);
  br->fdbd = _24;
  # DEBUG BEGIN_STMT
  _25 = br->fdbd;
  if (_25 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  mem_free (br);
  # DEBUG BEGIN_STMT
  D.7365 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  netif->hostname = "lwip";
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->link_type = 6;
  # DEBUG BEGIN_STMT
  netif->link_speed = 0;
  # DEBUG BEGIN_STMT
  netif->ts = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifinoctets = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifinucastpkts = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifinnucastpkts = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifindiscards = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifinerrors = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifinunknownprotos = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifoutoctets = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifoutucastpkts = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifoutnucastpkts = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifoutdiscards = 0;
  # DEBUG BEGIN_STMT
  netif->mib2_counters.ifouterrors = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  netif->state = br;
  # DEBUG BEGIN_STMT
  netif->name[0] = 98;
  # DEBUG BEGIN_STMT
  netif->name[1] = 114;
  # DEBUG BEGIN_STMT
  netif->output = etharp_output;
  # DEBUG BEGIN_STMT
  netif->output_ip6 = ethip6_output;
  # DEBUG BEGIN_STMT
  netif->linkoutput = bridgeif_output;
  # DEBUG BEGIN_STMT
  netif->hwaddr_len = 6;
  # DEBUG BEGIN_STMT
  _26 = &netif->hwaddr;
  _27 = &br->ethaddr;
  memcpy (_26, _27, 6);
  # DEBUG BEGIN_STMT
  netif->mtu = 1500;
  # DEBUG BEGIN_STMT
  netif->flags = 126;
  # DEBUG BEGIN_STMT
  _28 = netif->mld_mac_filter;
  if (_28 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  ip6_allnodes_ll.addr[0] = 767;
  # DEBUG BEGIN_STMT
  ip6_allnodes_ll.addr[1] = 0;
  # DEBUG BEGIN_STMT
  ip6_allnodes_ll.addr[2] = 0;
  # DEBUG BEGIN_STMT
  ip6_allnodes_ll.addr[3] = 16777216;
  # DEBUG BEGIN_STMT
  ip6_allnodes_ll.zone = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _29 = netif->mld_mac_filter;
  _29 (netif, &ip6_allnodes_ll, 1);
  ip6_allnodes_ll = {CLOBBER};

  <bb 20> :
  # DEBUG BEGIN_STMT
  D.7365 = 0;

  <bb 21> :
  return D.7365;

}


bridgeif_input (struct pbuf * p, struct netif * netif)
{
  struct bridgeif_port_t * port;
  struct bridgeif_private_t * br;
  struct eth_addr * dst;
  struct eth_addr * src;
  bridgeif_portmask_t dstports;
  u8_t rx_idx;
  err_t D.7422;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (p == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  if (netif == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  D.7422 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  bridgeif_netif_client_id.16_1 = bridgeif_netif_client_id;
  _2 = (int) bridgeif_netif_client_id.16_1;
  port = netif->client_data[_2];
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (port == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 6>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (port == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _3 = port->bridge;
  if (_3 == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  D.7422 = -6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  br = port->bridge;
  # DEBUG BEGIN_STMT
  _4 = netif->num;
  rx_idx = _4 + 1;
  # DEBUG BEGIN_STMT
  p->if_idx = rx_idx;
  # DEBUG BEGIN_STMT
  dst = p->payload;
  # DEBUG BEGIN_STMT
  _5 = p->payload;
  src = _5 + 6;
  # DEBUG BEGIN_STMT
  _6 = src->addr[0];
  _7 = (int) _6;
  _8 = _7 & 1;
  if (_8 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _9 = br->fdbd;
  _10 = port->port_num;
  bridgeif_fdb_update_src (_9, src, _10);

  <bb 12> :
  # DEBUG BEGIN_STMT
  _11 = dst->addr[0];
  _12 = (int) _11;
  _13 = _12 & 1;
  if (_13 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 13> :
  # DEBUG BEGIN_STMT
  dstports = bridgeif_find_dst_ports (br, dst);
  # DEBUG BEGIN_STMT
  bridgeif_send_to_ports (br, p, dstports);
  # DEBUG BEGIN_STMT
  dstports.17_14 = (signed char) dstports;
  if (dstports.17_14 < 0)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _15 = br->netif;
  _16 = _15->input;
  _17 = br->netif;
  _18 = _16 (p, _17);
  if (_18 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 15> :
  # DEBUG BEGIN_STMT
  pbuf_free (p);
  goto <bb 17>; [INV]

  <bb 16> :
  # DEBUG BEGIN_STMT
  pbuf_free (p);

  <bb 17> :
  # DEBUG BEGIN_STMT
  D.7422 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 18> :
  # DEBUG BEGIN_STMT
  _19 = bridgeif_is_local_mac (br, dst);
  if (_19 != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _20 = br->netif;
  _21 = _20->input;
  _22 = br->netif;
  D.7422 = _21 (p, _22);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 20> :
  # DEBUG BEGIN_STMT
  dstports = bridgeif_find_dst_ports (br, dst);
  # DEBUG BEGIN_STMT
  bridgeif_send_to_ports (br, p, dstports);
  # DEBUG BEGIN_STMT
  pbuf_free (p);
  # DEBUG BEGIN_STMT
  D.7422 = 0;
  // predicted unlikely by early return (on trees) predictor.

  <bb 21> :
  return D.7422;

}


bridgeif_output (struct netif * netif, struct pbuf * p)
{
  bridgeif_portmask_t dstports;
  struct eth_addr * dst;
  struct bridgeif_private_t * br;
  err_t err;
  err_t D.7374;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  br = netif->state;
  # DEBUG BEGIN_STMT
  dst = p->payload;
  # DEBUG BEGIN_STMT
  dstports = bridgeif_find_dst_ports (br, dst);
  # DEBUG BEGIN_STMT
  err = bridgeif_send_to_ports (br, p, dstports);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = netif->mib2_counters.ifoutoctets;
  _2 = p->tot_len;
  _3 = (long unsigned int) _2;
  _4 = _1 + _3;
  netif->mib2_counters.ifoutoctets = _4;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _5 = p->payload;
  _6 = MEM[(u8_t *)_5];
  _7 = (int) _6;
  _8 = _7 & 1;
  if (_8 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _9 = netif->mib2_counters.ifoutnucastpkts;
  _10 = _9 + 1;
  netif->mib2_counters.ifoutnucastpkts = _10;
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _11 = netif->mib2_counters.ifoutucastpkts;
  _12 = _11 + 1;
  netif->mib2_counters.ifoutucastpkts = _12;

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _13 = lwip_stats.link.xmit;
  _14 = _13 + 1;
  lwip_stats.link.xmit = _14;
  # DEBUG BEGIN_STMT
  D.7374 = err;
  return D.7374;

}


bridgeif_send_to_ports (struct bridgeif_private_t * br, struct pbuf * p, bridgeif_portmask_t dstports)
{
  bridgeif_portmask_t mask;
  u8_t i;
  err_t ret_err;
  err_t err;
  err_t D.7388;

  <bb 2> :
  # DEBUG BEGIN_STMT
  ret_err = 0;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  mask = 1;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = dstports & mask;
  if (_1 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  err = bridgeif_send_to_port (br, p, i);
  # DEBUG BEGIN_STMT
  if (err != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  ret_err = err;

  <bb 6> :
  # DEBUG BEGIN_STMT
  i.14_2 = i;
  i = i.14_2 + 1;
  mask = mask << 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  if (i <= 6)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7388 = ret_err;
  return D.7388;

}


bridgeif_send_to_port (struct bridgeif_private_t * br, struct pbuf * p, u8_t dstport_idx)
{
  struct netif * portif;
  err_t D.7402;

  <bb 2> :
  # DEBUG BEGIN_STMT
  if (dstport_idx <= 6)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = br->max_ports;
  if (dstport_idx < _1)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _2 = br->ports;
  _3 = (unsigned int) dstport_idx;
  _4 = _3 * 12;
  _5 = _2 + _4;
  portif = _5->port_netif;
  # DEBUG BEGIN_STMT
  if (portif != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 5> :
  _6 = portif->linkoutput;
  if (_6 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _7 = portif->num;
  _8 = _7 + 1;
  _9 = p->if_idx;
  if (_8 != _9)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _10 = portif->flags;
  _11 = (unsigned int) _10;
  _12 = _11 >> 2;
  _13 = (_Bool) _12;
  if (_13 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _14 = portif->linkoutput;
  D.7402 = _14 (portif, p);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (dstport_idx != 7)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 10>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7402 = 0;

  <bb 12> :
  return D.7402;

}


bridgeif_is_local_mac (struct bridgeif_private_t * br, struct eth_addr * addr)
{
  struct netif * portif;
  int i;
  int D.7442;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _1 = br->netif;
  _2 = &_1->hwaddr;
  _3 = memcmp (_2, addr, 6);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  D.7442 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 9>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _4 = br->ports;
  i.18_5 = (unsigned int) i;
  _6 = i.18_5 * 12;
  _7 = _4 + _6;
  portif = _7->port_netif;
  # DEBUG BEGIN_STMT
  if (portif != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  _8 = &portif->hwaddr;
  _9 = memcmp (_8, addr, 6);
  if (_9 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7442 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 9> :
  # DEBUG BEGIN_STMT
  _10 = br->num_ports;
  _11 = (int) _10;
  if (i < _11)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7442 = 0;

  <bb 11> :
  return D.7442;

}


bridgeif_find_dst_ports (struct bridgeif_private_t * br, struct eth_addr * dst_addr)
{
  bridgeif_portmask_t ret;
  int i;
  bridgeif_portmask_t D.7380;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  _1 = br->fdbs;
  i.11_2 = (unsigned int) i;
  _3 = i.11_2 * 8;
  _4 = _1 + _3;
  _5 = _4->used;
  if (_5 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  _6 = br->fdbs;
  i.12_7 = (unsigned int) i;
  _8 = i.12_7 * 8;
  _9 = _6 + _8;
  _10 = &_9->addr;
  _11 = memcmp (_10, dst_addr, 6);
  if (_11 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  _12 = br->fdbs;
  i.13_13 = (unsigned int) i;
  _14 = i.13_13 * 8;
  _15 = _12 + _14;
  ret = _15->dst_ports;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7380 = ret;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 7> :
  # DEBUG BEGIN_STMT
  _16 = br->max_fdbs_entries;
  _17 = (int) _16;
  if (i < _17)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  _18 = dst_addr->addr[0];
  _19 = (int) _18;
  _20 = _19 & 1;
  if (_20 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7380 = 255;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _21 = br->fdbd;
  D.7380 = bridgeif_fdb_get_dst_ports (_21, dst_addr);

  <bb 11> :
  return D.7380;

}


bridgeif_fdb_remove (struct netif * bridgeif, const struct eth_addr * addr)
{
  struct bridgeif_private_t * br;
  int i;
  err_t D.7349;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (bridgeif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  br = bridgeif->state;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (br == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 13>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _1 = br->fdbs;
  i.5_2 = (unsigned int) i;
  _3 = i.5_2 * 8;
  _4 = _1 + _3;
  _5 = _4->used;
  if (_5 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  _6 = br->fdbs;
  i.6_7 = (unsigned int) i;
  _8 = i.6_7 * 8;
  _9 = _6 + _8;
  _10 = &_9->addr;
  _11 = memcmp (_10, addr, 6);
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _12 = br->fdbs;
  i.7_13 = (unsigned int) i;
  _14 = i.7_13 * 8;
  _15 = _12 + _14;
  _16 = _15->used;
  if (_16 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _17 = br->fdbs;
  i.8_18 = (unsigned int) i;
  _19 = i.8_18 * 8;
  _20 = _17 + _19;
  _21 = &_20->addr;
  _22 = memcmp (_21, addr, 6);
  if (_22 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  # DEBUG BEGIN_STMT
  _23 = br->fdbs;
  i.9_24 = (unsigned int) i;
  _25 = i.9_24 * 8;
  _26 = _23 + _25;
  memset (_26, 0, 8);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7349 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 13> :
  # DEBUG BEGIN_STMT
  _27 = br->max_fdbs_entries;
  _28 = (int) _27;
  if (i < _28)
    goto <bb 7>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7349 = -6;

  <bb 15> :
  return D.7349;

}


bridgeif_fdb_add (struct netif * bridgeif, const struct eth_addr * addr, bridgeif_portmask_t ports)
{
  struct bridgeif_private_t * br;
  int i;
  err_t D.7335;

  <bb 2> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (bridgeif == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 3>; [INV]

  <bb 4> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  br = bridgeif->state;
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  if (br == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  __asm__ __volatile__("BKPT #0
	");
  # DEBUG BEGIN_STMT
  goto <bb 5>; [INV]

  <bb 6> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = 0;
  goto <bb 11>; [INV]

  <bb 7> :
  # DEBUG BEGIN_STMT
  _1 = br->fdbs;
  i.0_2 = (unsigned int) i;
  _3 = i.0_2 * 8;
  _4 = _1 + _3;
  _5 = _4->used;
  if (_5 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  _6 = br->fdbs;
  i.1_7 = (unsigned int) i;
  _8 = i.1_7 * 8;
  _9 = _6 + _8;
  _10 = _9->used;
  if (_10 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  # DEBUG BEGIN_STMT
  _11 = br->fdbs;
  i.2_12 = (unsigned int) i;
  _13 = i.2_12 * 8;
  _14 = _11 + _13;
  _14->used = 1;
  # DEBUG BEGIN_STMT
  _15 = br->fdbs;
  i.3_16 = (unsigned int) i;
  _17 = i.3_16 * 8;
  _18 = _15 + _17;
  _18->dst_ports = ports;
  # DEBUG BEGIN_STMT
  _19 = br->fdbs;
  i.4_20 = (unsigned int) i;
  _21 = i.4_20 * 8;
  _22 = _19 + _21;
  _23 = &_22->addr;
  memcpy (_23, addr, 6);
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7335 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 10> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  i = i + 1;

  <bb 11> :
  # DEBUG BEGIN_STMT
  _24 = br->max_fdbs_entries;
  _25 = (int) _24;
  if (i < _25)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  # DEBUG BEGIN_STMT
  # DEBUG BEGIN_STMT
  D.7335 = -1;

  <bb 13> :
  return D.7335;

}


